---
title: "Accessibility impact of transport infrastructure: Spatial assessment of Bogota's future metro system"
author: "Andrés Restrepo Jiménez"
date: '2023-06-19'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

```{r}
library(r5r)
library(accessibility)
library(ggplot2)
library(aopdata)
library(gtfstools)
library(readr)
library(dplyr)
library(tidyr)
library(st)
library(httr)
library(sf)
library(patchwork)
library(tmap)
library(tmaptools)
library(forcats)
library(scales)
library(writexl)
library(DataExplorer)
library(osmextract)
library(osmdata)
library(leaflet) # for making the interactive map
library(elevatr) # DEM (Digital Elevation Model)
library(raster)
#library(terra) # Not installed
library(h3jsr) # H3 hegagonal grid
library(remotes)
library(h3)
library(lubridate) # date data management
library(hms) # date data management
library(zip)
```

## Temporary directory

Location

```{r}
tempdir()
```

Deletes

```{r}
# unlink(tempdir(), recursive = TRUE)
```

## Memory setup

```{r}
options(java.parameters = "-Xmx4G")
```

# Bus Rapid Transit network (BRT)

## Downloading the data (turn off)

Setting the temp file path

```{r}
# brt_path <- tempfile("brt", fileext = ".zip")
```

Downloading the BRT GTFS data

```{r}
# httr::GET(
#   "https://storage.googleapis.com/gtfs-estaticos/GTFS-2023-06-21.zip",
#   httr::write_disk(brt_path)
# )
```

Initial: The GTFS data is a static feed (2021-07-04) provided by the Transport Secretary of Bogota City Council available [here](https://datos.movilidadbogota.gov.co/datasets/599751603a494051b15ac3d4f1f38ec5/about).

Update: The data was updated with static feed (2023-06-21) provided by Transmilenio in their open data webpage and available [here](https://datosabiertos-transmilenio.hub.arcgis.com/documents/gtfs-est%C3%A1ticos-2023-06-21/about).



Review of tables of downloaded data

```{r}
# unzip(brt_path, list = TRUE)
```


```{r}
# brt_gtfs <- read_gtfs(brt_path)
# 
# names(brt_gtfs)
```

## Reading data locally


Reading data locally

```{r}
brt_gtfs <- read_gtfs("Data/Raw/Transport/BRT/GTFS-2023-06-21.zip")

names(brt_gtfs)
```

## Data inspection

### Summary

```{r}
summary(brt_gtfs)
```

### Validation

```{r}
validate_gtfs(
  "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip",
  output_path = "Data/Raw/Transport/BRT/Validation/",
  validator_path = download_validator(tempdir())
)
```





### Profiling

```{r}
plot_str(brt_gtfs)
```

### Agency

```{r}
head(brt_gtfs$agency)
```
```{r}
Datatypelist_brt_agency <- brt_gtfs$agency %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_brt_agency
```



### Routes

```{r}
head(brt_gtfs$routes)
```

#### Id

Number of rows in route table

```{r}
nrow(brt_gtfs$routes)
```

Number of route id's.

```{r}
n_distinct(brt_gtfs$routes$route_id)
```

There was 547 different routes in the BRT network, and 1086 in the new data.

#### Description

Number of descriptions

```{r}
n_distinct(brt_gtfs$routes$route_desc)
```

Description texts

```{r}
unique(brt_gtfs$routes$route_desc)
```
Filtering route id by desc value

##### Main corredor

```{r}
route_id_main <- filter(brt_gtfs$routes,  route_desc == "TRONCAL") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_main <- filter_by_route_id(brt_gtfs, route_id_main$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_main <- gtfstools::get_trip_geometry(brt_gtfs_main, file = "shapes")
```


##### Urban

```{r}
route_id_urban <- filter(brt_gtfs$routes,  route_desc == "URBANO") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_urban <- filter_by_route_id(brt_gtfs, route_id_urban$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_urban <- gtfstools::get_trip_geometry(brt_gtfs_urban, file = "shapes")
```

##### Feeder

```{r}
route_id_feeder <- filter(brt_gtfs$routes,  route_desc == "ALIMENTADOR") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_feeder <- filter_by_route_id(brt_gtfs, route_id_feeder$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_feeder <- gtfstools::get_trip_geometry(brt_gtfs_feeder, file = "shapes")
```

##### Feeder_V

```{r}
route_id_feeder_v <- filter(brt_gtfs$routes,  route_desc == "ALIMENTADOR_V") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_feeder_v <- filter_by_route_id(brt_gtfs, route_id_feeder_v$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_feeder_v <- gtfstools::get_trip_geometry(brt_gtfs_feeder_v, file = "shapes")
```


##### Complementary

```{r}
route_id_comp <- filter(brt_gtfs$routes,  route_desc == "COMPLEMENTARIO") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_comp <- filter_by_route_id(brt_gtfs, route_id_comp$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_comp <- gtfstools::get_trip_geometry(brt_gtfs_comp, file = "shapes")
```

##### Special

```{r}
route_id_special <- filter(brt_gtfs$routes,  route_desc == "ESPECIAL") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_special <- filter_by_route_id(brt_gtfs, route_id_special$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_special <- gtfstools::get_trip_geometry(brt_gtfs_special, file = "shapes")
```

##### Saving 

```{r}
# # Main
# geo_shapes_main %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Main",
#            delete_layer=TRUE)
# 
# geo_shapes_urban %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Urban",
#            delete_layer=TRUE)
# 
# geo_shapes_feeder %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Feeder",
#            delete_layer=TRUE)
# 
# geo_shapes_feeder_v %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#             "Feeder_v",
#             delete_layer=TRUE)
# 
# geo_shapes_comp %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Complementary",
#            delete_layer=TRUE)
# 
# geo_shapes_special %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Special",
#            delete_layer=TRUE)




```


Test


```{r}
# # Main
# geo_shapes_main %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Main")
# 
# geo_shapes_urban %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Urban")
# 
# geo_shapes_feeder %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Feeder")
# 
# geo_shapes_feeder_v %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Feeder_v")
# 
# geo_shapes_comp %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Complementary")
# 
# geo_shapes_special %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Special")


```



#### Type

Number of types

```{r}
n_distinct(brt_gtfs$routes$route_type)
```

Type texts

```{r}
unique(brt_gtfs$routes$route_type)
```

Consistent with official GTFS [specification](https://gtfs.org/schedule/reference/#routestxt).

### Trips

```{r}
head(brt_gtfs$trips)
```

**How can you tell the direction?** **It does not have the shape id**

Number of routes in table

```{r}
n_distinct(brt_gtfs$trips$route_id)
```

Number of uniques entries

```{r}
n_distinct(brt_gtfs$trips)
```

There were 158976 trips included in the initial BRT GTFS data and 179454 in the updated data.

#### Case 1

Routes: Z_7295 and Z_7295-2.

```{r}
brt_gtfs_trip_c1 <- filter_by_route_id(brt_gtfs, c("Z_7295", "Z_7295-2") , keep = TRUE)
```

Get geometry

```{r}
geo_brt_gtfs_trip_c1 <- gtfstools::get_trip_geometry(brt_gtfs_trip_c1, file = "shapes")
```

Plot

```{r}
qtm(geo_brt_gtfs_trip_c1)
```

Stop times

```{r}
View(brt_gtfs_trip_c1$stop_times)
```



### Stops

```{r}
head(brt_gtfs$stops)
```

Number of stations

```{r}
n_distinct(brt_gtfs$stops)
```

Convert stops to sf

```{r}
brt_stations_sf <- st_as_sf(brt_gtfs$stops,coords = c("stop_lon", "stop_lat"), crs = 4326 )
```

Plot stations

```{r}
brt_stations_sf %>%
  st_geometry() %>%
  plot()
```

Basic geo map

```{r}
ggplot() +
  geom_sf(data = brt_stations_sf) +
  theme_minimal()
```

#### Id

Number of rows in station table

```{r}
n_distinct(brt_gtfs$stops$stop_id)
```

There were 7819 different stations in the BRT network, and 8214 in the new data.

#### Stop code

Number of rows in station table

```{r}
n_distinct(brt_gtfs$stops$stop_code)
```

Stop code and stop id seem to be equivalent.

### Calendar

```{r}
head(brt_gtfs$calendar)
```

From 1-5, it is the same schedule in the intial data, 2-5 in the new data.

```{r}
Datatypelist_brt_calendar <- brt_gtfs$calendar %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_brt_calendar
```



### Calendar dates

```{r}
head(brt_gtfs$calendar_dates)
```

Number of exceptions

```{r}
n_distinct(brt_gtfs$calendar_dates)
```

#### Exception type

Exeption_type: "Indicates whether service is available on the date specified in the date field.

Valid options are:

1 - Service has been added for the specified date. 2 - Service has been removed for the specified date."

```{r}
unique(brt_gtfs$calendar_dates$exception_type)
```

Number of different dates in calendar dates

```{r}
unique(brt_gtfs$calendar_dates$date)
```

It seems to be holidays in Colombia.

#### Service id

```{r}
n_distinct(brt_gtfs$calendar_dates$service_id)
```




### Shapes

```{r}
head(brt_gtfs$shapes)
```

Number of shapes entries in table

```{r}
n_distinct(brt_gtfs$shapes$shape_id)
```

Number of unique entries

```{r}
n_distinct(brt_gtfs$shapes)
```

#### Geometry

Getting geometry from new data

```{r}
geo_shapes <- gtfstools::get_trip_geometry(brt_gtfs, file = "shapes")
```

The new object is already a sf object.

Review

```{r}
head(geo_shapes)
```

###### Saving

Saving shapes as geopackage (not working)

```{r}
# geo_shapes %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Complete_Network",
#            delete_layer=TRUE)
```

Plotting geometry onlyv (too big)

```{r}
# geo_shapes %>%
#   st_geometry() %>%
#   plot()
```

Basic geo map (too big)

```{r}
# ggplot() +
#   geom_sf(data = geo_shapes) +
#   theme_minimal()
```

##### Sample of geometries

```{r}
set.seed(123) 

sample <- sample(brt_gtfs$trips$trip_id,1000)

head(sample)
```
Subsetting geometries

```{r}
geo_shapes_sample<- gtfstools::get_trip_geometry(brt_gtfs,file = "shapes", trip_id = sample)
```


```{r}
head(geo_shapes_sample)
```
Plotting sample geometries

```{r}
ggplot() +
  geom_sf(data = geo_shapes_sample) +
  theme_minimal()
```


##### Check for valid geometries

```{r}
unique(st_is_valid(geo_shapes))
```
There are invalid geometries in the new data.

##### Empty geometries (not working)

```{r}
unique(st_is_empty(geo_shapes))
```
There are not empty geometries in new data set.

##### Remove invalid geometries (not used in new data yet)

```{r}
# invalid_geometries <- !st_is_valid(geo_from_stops_filtered)
# 
# geo_from_stops_filtered <- geo_from_stops_filtered[invalid_geometries == FALSE, ]
```


### Stops times

```{r}
summary(brt_gtfs$stop_times)
```

```{r}
head(brt_gtfs$stop_times)
```

```{r}
brt_gtfs$stop_times
```

Filter stop sequence 0 values

```{r}
filter(brt_gtfs$stop_times, stop_sequence == 0)
```

Initial data: Count of 0 stop sequence values. New data: Zero entries with 0 value in stop sequence field.

```{r}
stop_cero_sequence <- filter(brt_gtfs$stop_times, stop_sequence == 0) %>%
  group_by(stop_id) %>%
  summarize(count_cero = n()) #%>%

stop_cero_sequence <- stop_cero_sequence[order(desc(stop_cero_sequence$count_cero)),]

```

Blank output.

#### Trip Id

```{r}
n_distinct(brt_gtfs$stop_times$trip_id)
```

Sorting by trip id

```{r}
brt_gtfs$stop_times[order(trip_id)]
```


#### Stop sequence

Unique value in stop_sequence field

```{r}
n_distinct(brt_gtfs$stop_times$stop_sequence)
```

Histogram on stop sequence values

```{r}
histo_stop_sequence <- ggplot(brt_gtfs$stop_times, aes(x=stop_sequence)) +
  ggtitle("Histogram of stop sequence values") + 
  geom_histogram() + xlab("Stop sequence")
histo_stop_sequence
```

Multiple stations with "1" values in the stop sequence.

Filter entries with zero values in stop time stop sequence field

```{r}
filter(brt_gtfs$stop_times, stop_sequence==0)
```

Zero entries with zero value in the stop sequence field

Filter a specific trip

##### Number of stations by trip (remove)


Adjusted count

```{r}
# stops_by_trip <- brt_gtfs$stop_times %>%
#   group_by(trip_id, stop_sequence) %>%
#   summarize(count_stop_sequence = n()) %>%
#   pivot_wider(names_from = stop_sequence, values_from = count_stop_sequence, values_fill = 0,names_prefix = "S_")
# 
# head(stops_by_trip)
```
Extract stops_by_trip to excel

```{r}
# write_xlsx(stops_by_trip,"Test/stops_by_trip.xlsx")
```



##### Case 1 

Two stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BC42D0021-04-2_T_1785")
```

Review of individual geometry

```{r}
geo_case_1 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BC42D0021-04-2_T_1785")
```

The new object is already a sf object.

Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_1) +
  theme_minimal()
```

Although, there are only 2 points, with the shape table data, the geometry output shows a smooth route.

##### Case 2

Tree stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BO7ED0007-02-2_T_2192")
```

Review of individual geometry

```{r}
geo_case_2 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BO7ED0007-02-2_T_2192")
```


Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_2) +
  theme_minimal()
```

##### Case 3

Four stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BCGIA0007-13-3_Z_6441")
```

Same example with -2 suffix

```{r}
filter(brt_gtfs$stop_times, trip_id == "BCGIA0007-13-3_Z_6441-2")
```

Review of individual geometry

```{r}
geo_case_3 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BCGIA0007-13-3_Z_6441")
```


Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_3) +
  theme_minimal()
```


### Frequencies (blank)

```{r}
head(brt_gtfs$frequencies)
```

```{r}
brt_gtfs$frequencies
```

There is no data in the frequencies table.

### Fare attributes

```{r}
head(brt_gtfs$fare_attributes)
```

```{r}
brt_gtfs$fare_attributes
```

Types of fare (price) information by agency.

Transfers
1. 0 indicate no transfers permitted.
NA. indicates Unlimited transfers are permitted.

### Fare rules

```{r}
head(brt_gtfs$fare_rules)
```

```{r}
brt_gtfs$fare_rules
```

#### Fare id

```{r}
unique(brt_gtfs$fare_rules$fare_id)
```
Fare 2 missing

#### Route id

```{r}
length(unique(brt_gtfs$fare_rules$route_id))
```

Fare information for 1086 routes.


### Route detailed review

#### Case 1

Route 6-4, "6-4" in route id field with id 

```{r}
brt_gtfs_C1_1 <- filter_by_route_id(brt_gtfs, "T_1899", keep = TRUE)
```


##### Route

```{r}
brt_gtfs_C1$routes
```
##### Trips

```{r}
brt_gtfs_C1$trips
```

Schedule: Monday to Friday.

Number of trips

```{r}
length(unique(brt_gtfs_C1$trips$trip_id))
```
There are 666 trips for this route.


##### Shapes

```{r}
brt_gtfs_C1$shapes
```

Geometry

```{r}
geo_brt_gtfs_C1 <- gtfstools::get_trip_geometry(brt_gtfs_C1,file = "shapes")
```

Review

```{r}
geo_brt_gtfs_C1
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_brt_gtfs_C1) +
  theme_minimal()
```
##### Stops

```{r}
brt_gtfs_C1$stops
```

Convert stops to sf

```{r}
geo_brt_stations_C1_sf <- st_as_sf(brt_gtfs_C1$stops,coords = c("stop_lon", "stop_lat"), crs = 4326)
```

Plot stations

```{r}
geo_brt_stations_C1_sf %>%
  st_geometry() %>%
  plot()
```
##### Stop times

```{r}
arrange(brt_gtfs_C1$stop_times, trip_id, stop_sequence)
```


##### Fare attribute

```{r}
brt_gtfs_C1$fare_attributes
```

##### Fare rules

```{r}
brt_gtfs_C1$fare_rules
```
##### Plotting

```{r}
ggplot() +
  geom_sf(data = geo_brt_stations_C1_sf) + 
  geom_sf(data = geo_brt_gtfs_C1) + 
  theme_minimal()
```
###### Case 1 - 1

```{r}
brt_gtfs_C1_1 <- filter_by_trip_id(brt_gtfs, "BC4290001-02-3_T_1899", keep = TRUE)
```


###### Testing track and stations and track overlap in brt case

Routes

```{r}
brt_gtfs_C1_1$routes
```
Trips

```{r}
brt_gtfs_C1_1$trips
```
Shape

```{r}
brt_gtfs_C1_1$shapes
```

Geometry

```{r}
geo_brt_gtfs_C1_1 <- gtfstools::get_trip_geometry(brt_gtfs_C1_1,file = "shapes")
```

Review

```{r}
geo_brt_gtfs_C1_1
```
Stops

```{r}
brt_gtfs_C1_1$stops
```

Convert stops to sf

```{r}
geo_brt_stations_C1_1_sf <- st_as_sf(brt_gtfs_C1_1$stops,coords = c("stop_lon", "stop_lat"), crs = 4326)
```

Plot stations

```{r}
geo_brt_stations_C1_1_sf %>%
  st_geometry() %>%
  plot()
```
Stop time

```{r}
arrange(brt_gtfs_C1_1$stop_times, trip_id, stop_sequence)
```




```{r}
inter_brt_stops_shape_1 <- st_intersection(geo_brt_stations_C1_1_sf,geo_brt_gtfs_C1_1)
```
Review

```{r}
inter_brt_stops_shape_1
```
Plotting

```{r}
ggplot() +
  geom_sf(data = inter_brt_stops_shape_1) +
  theme_minimal()
```
There is overlaping between stations and trip shape


### Validation

## Data cleaning (pending)

# OSM network

## Data reading

Open Street Map Data downloaded from: <https://export.hotosm.org/es/v3/>

```{r}
osm_network <- oe_read("Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf") 
```

Plotting

```{r}
# par(mar = rep(0.001, 4))
# plot(sf::st_geometry(osm_network))
```

## Data inspection

### CRS

```{r}
st_crs(osm_network)
```

### Profilling

```{r}
plot_missing(osm_network)
```

Filter by highway value

```{r}
osm_by_highway<- osm_network %>%
  group_by(highway) %>%
  summarize(count_entry = n()) %>%
  arrange(desc(count_entry))
  

osm_by_highway
```

Plotting by highway value

```{r}
osm_subsetting <- osm_by_highway %>%
  filter(., highway == "residential")


par(mar = rep(0.1, 4))
plot(sf::st_geometry(osm_subsetting))
```

Interactive map by subsetting value

```{r}
# leaflet() %>% 
#   addTiles() %>% 
#   addPolylines(data = osm_subsetting)

```

**What sub-setting should be done before the accessibility modelling?**

## Data cleaning (Non-existing)

# Metro system

## GTFS data generation

Generates the main tables of the GTFS metro data.

### Agency

```{r}
metro_agency <- tibble::tribble(
  ~agency_id, ~agency_name, ~agency_url, ~agency_timezone, ~agency_lang, ~agency_phone,
  "1","Metro de Bogota","https://www.metrodebogota.gov.co/","America/Bogota","es", "(+57)601-555-33-33")

```

Generates table

```{r}
data.table::setDT(metro_agency)
```


### Routes

Create a metro route table

```{r}
metro_routes <- tibble::tribble(
  ~route_id,  ~route_short_name,~route_long_name, ~route_desc, ~agency_id, ~route_color, ~route_text_color, ~route_type,
  "M1_001", "S_001", "South", "Main", "1", "FFFFFF", "000000", "1",
  "M1_002", "N_001", "North", "Main", "1", "FFFFFF", "000000", "1")
```

Reads it as data frame

```{r}
data.table::setDT(metro_routes)
```


### Trips

The trip id field will follow the structure: ROUTEID_DIRECTION_SERVICEID_SHAPE_ID

DIRECTION:
N: North
S: South


```{r}
metro_trips <- tibble::tribble(
  ~route_id,  ~service_id,~trip_id, ~shape_id,
  "M1_001", "3", "M1_001_S_3_M1_001", "M1_001",
  "M1_002", "3", "M1_002_N_3_M1_002", "M1_002")
```

Reads it as a table

```{r}
data.table::setDT(metro_trips)
```



### Stops

Reading stations data of first line of metro.

```{r}
raw_metro_stations <- st_read("Data/Raw/Transport/Metro/Stations/ESTACIONES.shp") %>%
  st_transform(.,4326)
```
Review CRS

```{r}
st_crs(raw_metro_stations)
```

Geometry

```{r}
qtm(raw_metro_stations)
```

Calculates the centroids of every station polygon

```{r}
metro_stops <- raw_metro_stations %>%
  st_centroid() %>%
  rename(stop_name = RefName) %>%
  rename(stop_id = NOMBRE) %>%
  rename(stop_code = NUMERO)
  
```
Stops

```{r}
head(metro_stops)
```

Calculate longitude and latitude coordinates of centroids

```{r}
metro_stops$stop_lon <- st_coordinates(metro_stops)[, 1]
metro_stops$stop_lat <- st_coordinates(metro_stops)[, 2]

```

Adjust station code, populate location_type and zone_id

```{r}
metro_stops$location_type <- "0"
metro_stops$zone_id <- "0"
metro_stops$stop_id <- gsub("E", "M", metro_stops$stop_id)
```

Dropping columns and geometry and relocating columns

```{r}
metro_stops <- metro_stops %>%
  st_drop_geometry(.) %>%
  dplyr::select(!c(OBJECTID,TIPO, Shape_Leng, Shape_Area)) %>%
  relocate(stop_id) %>%
  relocate(stop_code, .after = stop_id) %>%
  relocate(stop_lat, .after = stop_name)
```

Ordering 

```{r}
metro_stops <- metro_stops[order(metro_stops$stop_code),]
```



### Calendar

Creating a mirror calendar table from the BRT GTFS data.

```{r}
metro_calendar <- brt_gtfs$calendar
```

Removes string characters

```{r}
metro_calendar$start_date <- gsub('-','',metro_calendar$start_date)
metro_calendar$end_date <- gsub('-','',metro_calendar$end_date)
```

### Calendar dates

Creating a mirror calendar date table from the BRT GTFS data (only for year 2022).

```{r}
metro_calendar_dates <- brt_gtfs$calendar_dates
```

"1 - Service has been added for the specified date. 
2 - Service has been removed for the specified date."

Removes string characters

```{r}
metro_calendar_dates$date <- gsub('-','',metro_calendar_dates$date)
```



### Shapes

Reading track data of first line of metro.

```{r}
raw_metro_line <- st_read("Data/Raw/Transport/Metro/Track/TRAZADO_PLMB.shp") %>%
  st_transform(.,4326)
```

Review CRS

```{r}
st_crs(raw_metro_line)
```

Geometry

```{r}
ggplot() +
  geom_sf(data = raw_metro_line) +
  theme_minimal()
```
#### North direction shape

Create sf for north direction

```{r}
raw_metro_line_north <- raw_metro_line
```


Create shape id column

```{r}
raw_metro_line_north$shape_id = "M1_002"
```

Relocate columns

```{r}
raw_metro_line_north <- raw_metro_line_north  %>%
  relocate(shape_id)
```

Create shape table from sf object

```{r}
metro_shapes_north <- convert_sf_to_shapes(raw_metro_line_north, shape_id = NULL)
```

Sequence is build west to east in the shape table.

#### South direction shape

Reverse raw geometry for south direction shape

```{r}
raw_metro_line_south <- st_reverse(raw_metro_line)
```

Create shape id column

```{r}
raw_metro_line_south$shape_id = "M1_001"
```

Relocate columns

```{r}
raw_metro_line_south <- raw_metro_line_south  %>%
  relocate(shape_id)
```

Create shape table from sf object

```{r}
metro_shapes_south <- convert_sf_to_shapes(raw_metro_line_south, shape_id = NULL)
```

#### Apending shapes

```{r}
metro_shapes <- bind_rows(metro_shapes_south,metro_shapes_north)
```

Droping columns

```{r}
metro_shapes <- metro_shapes %>%
  dplyr::select(!c(OBJECTID_1, OBJECTID, NOMBRE, Shape_Leng, z))
```

### Stops: Alternative method


Intersect with route geometry

```{r}
inter_metro_stops_alternative <- st_intersection(raw_metro_stations,raw_metro_line)
```
Plotting

```{r}
ggplot() +
  geom_sf(data = inter_metro_stops_alternative) +
  theme_minimal()
```
Calculates the centroids of every station line

```{r}
metro_stops_a <- inter_metro_stops_alternative %>%
  st_centroid() %>%
  rename(stop_name = RefName) %>%
  rename(stop_id = NOMBRE) %>%
  rename(stop_code = NUMERO)
  
```

Stops

```{r}
head(metro_stops_a)
```

Calculate longitude and latitude coordinates of centroids

```{r}
metro_stops_a$stop_lon <- st_coordinates(metro_stops_a)[, 1]
metro_stops_a$stop_lat <- st_coordinates(metro_stops_a)[, 2]

```

Adjust station code, populate location_type and zone_id

```{r}
metro_stops_a$location_type <- "0"
metro_stops_a$zone_id <- "0"
metro_stops_a$stop_id <- gsub("E", "M", metro_stops_a$stop_id)
```

Dropping columns and geometry and relocating columns

```{r}
metro_stops_a <- metro_stops_a %>%
  st_drop_geometry(.) %>%
  dplyr::select(!c(OBJECTID,TIPO, Shape_Leng, Shape_Area, OBJECTID_1,OBJECTID.1,NOMBRE.1,Shape_Leng.1)) %>%
  relocate(stop_id) %>%
  relocate(stop_code, .after = stop_id) %>%
  relocate(stop_lat, .after = stop_name)
```

Ordering 

```{r}
metro_stops_a <- metro_stops_a[order(metro_stops_a$stop_code),]
```



### Stop times

#### Distance calculation

Point only geometry

```{r}
metro_stations_points <- raw_metro_stations %>%
  st_centroid()
```
Sorting stations

```{r}
metro_stations_points <- metro_stations_points[order(metro_stations_points$NUMERO),]
```


Calculating distance between stations

```{r}
distance_stations <- st_distance(metro_stations_points,metro_stations_points)
```

Iterate to calculate distance from next station

```{r}

distance_list<- list()
origin_list <- list()
destination_list <- list()

for (i in 1:(nrow(distance_stations) - 1)) {
  
  temp_distances <- c()
  distance_ij <- distance_stations[i, i+1]
  temp_distances <- c(temp_distances, distance_ij)
  distance_list <- append(distance_list, temp_distances)
  
  temp_origin <- c()
  origin_i <- i
  temp_origin <- c(temp_origin,origin_i)
  origin_list<- append(origin_list,temp_origin)
  
  
  
  temp_destination <- c()
  destination_j <- i + 1
  temp_destination <- c(temp_destination,destination_j)
  destination_list <- append(destination_list,temp_destination)
  
  
}
```

Read as a data frame

```{r}
distance_stations_df <- data.frame(o_station = unlist(origin_list), d_station =  unlist(destination_list),distance = unlist(distance_list))
```

#### Setting trip speed

Initial speed setting: 43 km/h according to [Metro de bogotá](https://www.metrodebogota.gov.co/?q=que-es-metro#:~:text=Conectar%C3%A1n%20el%20sur%20y%20el,de%20las%20obras%20del%20viaducto.) 

```{r}
speed_km_per_h <- 43 # speed in km/h
speed_m_per_m <- (speed_km_per_h*1000)/60 # speed in meters/minute
```

Calculate duration of trip between stations

```{r}
distance_stations_df <- distance_stations_df %>%
  mutate(dura_min = distance/speed_m_per_m)
```

#### North direction trip

Stop time table for the north direction trip

```{r}
metro_stop_times_N <- metro_stops %>%
  mutate(trip_id = metro_trips$trip_id[2]) %>%
  relocate(trip_id)
```

Temporary list with zero in the final value

```{r}
temp_time_to_next_N <- list()
temp_time_to_next_N <- as.list(distance_stations_df$dura_min)
temp_time_to_next_N <- append(temp_time_to_next_N,0)
```

Append list in metro stops table

```{r}
metro_stop_times_N <- metro_stop_times_N %>%
  mutate(time_to_next = unlist(temp_time_to_next_N))
  
```

Creates the arrival and departure time columns

```{r}
metro_stop_times_N$arrival_time <- as_hms("08:00:00")
metro_stop_times_N$departure_time <- as_hms("08:00:00")

```

Iterate to calculate arrival and departure time according to time_to_next station

```{r}

for (i in 2:(nrow(metro_stop_times_N))) {
  
  metro_stop_times_N$arrival_time[i] = as_hms(metro_stop_times_N$departure_time[i-1] + hms(seconds = ceiling(metro_stop_times_N$time_to_next[i-1]*60)))
  
  metro_stop_times_N$departure_time[i] = metro_stop_times_N$arrival_time[i]
}


```

Creates the stop sequence field

```{r}

metro_stop_times_N$stop_sequence <- 0

for (i in 1:(nrow(metro_stop_times_N))) {
  metro_stop_times_N$stop_sequence[i] = i

}
```

Creates the timepoint field

```{r}
metro_stop_times_N$timepoint <- 0
```

Droping columns

```{r}
metro_stop_times_N <- metro_stop_times_N %>%
  dplyr::select(c(trip_id, arrival_time, departure_time, stop_id, stop_sequence, timepoint))
```


#### South direction trip

Stop time table for the south direction trip

```{r}
metro_stop_times_S <- metro_stops %>%
  mutate(trip_id = metro_trips$trip_id[1]) %>%
  relocate(trip_id)
```

Inverse sorting

```{r}
metro_stop_times_S <- metro_stop_times_S[order(metro_stop_times_S$stop_code,decreasing = TRUE),]
```


Temporary list with zero in the final value

```{r}
temp_time_to_next_S <- list()
temp_time_to_next_S <- rev (as.list(distance_stations_df$dura_min)) #Inverse sorting
temp_time_to_next_S <- append(temp_time_to_next_S,0)
```

Append list in metro stops table

```{r}
metro_stop_times_S <- metro_stop_times_S %>%
  mutate(time_to_next = unlist(temp_time_to_next_S))
  
```

Creates the arrival and departure time columns

```{r}
metro_stop_times_S$arrival_time <- as_hms("04:00:00")
metro_stop_times_S$departure_time <- as_hms("04:00:00")

```

Iterate to calculate arrival and departure time according to time_to_next station

```{r}

for (i in 2:(nrow(metro_stop_times_S))) {
  
  metro_stop_times_S$arrival_time[i] = as_hms(metro_stop_times_S$departure_time[i-1] + hms(seconds = ceiling(metro_stop_times_S$time_to_next[i-1]*60)))
  
  metro_stop_times_S$departure_time[i] = metro_stop_times_S$arrival_time[i]
}


```

Creates the stop sequence field

```{r}

metro_stop_times_S$stop_sequence <- 0

for (i in 1:(nrow(metro_stop_times_S))) {
  metro_stop_times_S$stop_sequence[i] = i

}
```

Creates the timepoint field

```{r}
metro_stop_times_S$timepoint <- 0
```

Droping columns

```{r}
metro_stop_times_S <- metro_stop_times_S %>%
  dplyr::select(c(trip_id, arrival_time, departure_time, stop_id, stop_sequence, timepoint))
```

#### Appeding trips

Appends both north and south direction trips

```{r}
metro_stop_times_full <- bind_rows(metro_stop_times_N,metro_stop_times_S)
```



### Frequencies

Peak, off peak hours and periodicity

```{r}
start_time_list <- list("00:00:00","05:30:00", "09:00:00", "16:00:00", "19:00:00")
end_time_list <- list("05:29:59","08:59:59","15:59:59", "18:59:59","23:59:59")
periodicity_list <- list(15,3,15,3,15)
```

#### North direction trip

Creates frequencies initial data frame

```{r}
metro_frequencies_columns = c(names(brt_gtfs$frequencies)) 
metro_frequencies_N = data.frame(matrix(nrow = 5, ncol = length(metro_frequencies_columns))) 
colnames(metro_frequencies_N) = metro_frequencies_columns
```

Assign trip value, star and end time values

```{r}
metro_frequencies_N$trip_id <- metro_trips$trip_id[2]
metro_frequencies_N$start_time <- as_hms("00:00:00")
metro_frequencies_N$end_time <- as_hms("00:00:00")
```



Assign to dataframe

```{r}
metro_frequencies_N$start_time <- unlist(start_time_list)
metro_frequencies_N$end_time <- unlist(end_time_list)
metro_frequencies_N$periodicity <- unlist(periodicity_list)
```

Calculate headway_secs

```{r}
metro_frequencies_N$headway_secs <- metro_frequencies_N$periodicity*60
```

#### South direction trip

Creates mirror frequency table for south direction trip

```{r}
metro_frequencies_S <- metro_frequencies_N
metro_frequencies_S$trip_id <- metro_trips$trip_id[1]
```

#### Appending trips

Appends both north and south direction trips

```{r}
metro_frequencies_full <- bind_rows(metro_frequencies_S,metro_frequencies_N)
```

Droping periodicity columns

```{r}
metro_frequencies_full <- metro_frequencies_full %>%
  dplyr::select(!c(periodicity))
```

Creating exact time column

```{r}
metro_frequencies_full$exact_times <- 0
```



### Fare attributes (non-existing)

### Fare rules (non-existing)

### Compilation

#### Write

List of origin and destination files

```{r}
items <- list(
  metro_agency = "agency.txt",
  metro_routes = "routes.txt",
  metro_trips = "trips.txt",
  metro_stops_a = "stops.txt",
  metro_calendar = "calendar.txt",
  metro_calendar_dates = "calendar_dates.txt",
  metro_shapes = "shapes.txt",
  metro_stop_times_full = "stop_times.txt",
  metro_frequencies_full = "frequencies.txt"
)
```

Input directory

```{r}
input_directory <- "Data/Preprocessed/Metro/GTFS/Inputs/"
```


Writes dataframes as txt files

```{r}

for (i in names(items)) {
  file_path <- paste0(input_directory, items[[i]])
  write.table(get(i), file_path, sep=",", quote=FALSE, row.names = FALSE)
}
```



#### Store


Creates zipfile

```{r}
zip(zipfile = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", files = list.files("Data/Preprocessed/Metro/GTFS/Inputs/", full.names = TRUE),mode = "cherry-pick")

```


#### Read

Reads resulting Metro GTFS Data

```{r}
metro_gtfs <- read_gtfs("Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip")

names(metro_gtfs)
```

## Data inspection

### Summary

```{r}
summary(metro_gtfs)
```
### Profiling

```{r}
plot_str(metro_gtfs)
```

### Validation

```{r}
validate_gtfs(
  "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip",
  output_path = "Data/Preprocessed/Metro/GTFS/Validation/",
  validator_path = download_validator(tempdir())
)
```

### Review

#### Agency

```{r}
head(metro_gtfs$agency)
```
```{r}
Datatypelist_metro_agency <- metro_gtfs$agency %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_metro_agency
```




#### Routes

```{r}
head(metro_gtfs$routes)
```

#### Trips

```{r}
metro_gtfs$trips
```

#### Stops

Reads stop_lat and stop_lon as numeric

```{r}
metro_gtfs$stops$stop_lat = as.numeric(as.character(metro_gtfs$stops$stop_lat))
metro_gtfs$stops$stop_lon = as.numeric(as.character(metro_gtfs$stops$stop_lon))
```

Dataframe

```{r}
metro_gtfs$stops
```

#### Calendar

```{r}
metro_gtfs$calendar
```
Data type

```{r}
Datatypelist_metro_calendar <- metro_gtfs$calendar %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_metro_calendar
```




#### Calendar dates

```{r}
metro_gtfs$calendar_dates
```

#### Shapes

Reads as numeric

```{r}
metro_gtfs$shapes$shape_dist_traveled = as.numeric(as.character(metro_gtfs$shapes$shape_dist_traveled))
metro_gtfs$shapes$Shape_Leng = as.numeric(as.character(metro_gtfs$shapes$Shape_Leng))
```


Dataframe

```{r}
metro_gtfs$shapes
```

Geometry

```{r}
geo_metro_shapes <- gtfstools::get_trip_geometry(metro_gtfs, file = "shapes")
```

Qtm

```{r}
qtm(geo_metro_shapes)
```

##### Saving

```{r}
geo_metro_shapes %>%
  st_write("Data/Preprocessed/Metro/Network/Metro_Network.gpkg",
           "Main",
           delete_layer=TRUE)
```



#### Stop times

Dataframe

```{r}
metro_gtfs$stop_times
```

#### Frequencies

Dataframe

```{r}
metro_gtfs$frequencies
```

#### Detail review

##### Testing track and stations and track overlap in metro case

Geometry of track

```{r}
geo_metro_shapes <- gtfstools::get_trip_geometry(metro_gtfs, file = "shapes")
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_shapes) +
  theme_minimal()
```


Geometry of stations

```{r}
geo_metro_stations <- convert_stops_to_sf(metro_gtfs, stop_id = NULL, crs = 4326)
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_stations) +
  theme_minimal()
```

Overlap of station point

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_stations) +
  geom_sf(data = geo_metro_shapes) + 
  theme_minimal()
```
Intesect

```{r}
inter_metro_stops_shape <- st_intersection(geo_metro_stations,geo_metro_shapes)
```
Review

```{r}
inter_metro_stops_shape
```
__No intersection between stops and track of metro__





## Data cleaning (non-existing)

# Multipurpose survey

## Reading the data

### ZPU layer

```{r}
geo_zpu <- st_read("Data/Raw/Demo/Survey/Shape/ShapeEM2021/EM2021_UPZ.shp")
```

Geometry

```{r}
qtm(geo_zpu)
```

### Survey data

#### Main forms

Downloading and reading from source

```{r}
# url<- "https://www.sdp.gov.co/sites/default/files/encuestas-multiproposito/20230620em2021.zip"
# 
# download.file(url,"Data/Survey/CSV_Main/20230620em2021.zip")
# 
# unzip("Data/Survey/CSV_Main/20230620em2021.zip",exdir = "Data/Survey/CSV_Main")
# 
# survey_raw <- read_csv("Data/Survey/CSV_Main/20230620EM2021.csv")
```

Reading from local

```{r}
survey_raw <- read_csv("Data/Raw/Demo/Survey/CSV_Main/20230620EM2021.csv")
```

Preview

```{r}
head(survey_raw,10)
```

#### Additional variables

Downloading and reading from source

```{r}
# url<- "https://www.sdp.gov.co/sites/default/files/encuestas-multiproposito/20230220_variables_adicionales_em2021_csv.zip"
# 
# download.file(url,"Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021_csv.zip")
# 
# unzip("Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021_csv.zip",exdir = "Data/Survey/CSV_Additional")
# 
# survey_add_raw <- read_csv("Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021.csv")
```

Reading from local

```{r}
survey_add_raw <- read_csv("Data/Raw/Demo/Survey/CSV_Additional/20230220_variables_adicionales_em2021.csv")
```

Preview

```{r}
head(survey_add_raw,10)
```

## Data inspection

### ZPU layer

CRS

```{r}
st_crs(geo_zpu)
```

Summary

```{r}
summary(geo_zpu)
```

UPZEM: Numeric UPZEM2: String

### Survey data

#### Main forms

Data type

```{r}
Datatypelist_survey <- survey_raw %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist_survey
```

##### Profiling

Summary

```{r}
introduce(survey_raw)
```

Missing values

```{r}
plot_missing(survey_raw)
```

Missing values on ID fields

```{r}
survey_raw_id <- survey_raw %>% 
  dplyr::select(directorio, directorio_per, dpto, mpio, clase, cod_localidad, nombre_localidad, cod_upz_grupo, nombre_upz_grupo, estrato2021, nombre_estrato, fex_c)

plot_missing(survey_raw_id)

```

Missing values by ZPU

```{r}
na_by_zpu <- survey_raw %>%
  group_by(cod_upz_grupo) %>%
  summarize(count_entry = n()) %>%
  mutate(percentage_entry = count_entry / nrow(survey_raw) * 100) %>%
  arrange(desc(percentage_entry))

head(na_by_zpu)
```

Missing ZPU by "directorio"

```{r}
entry_by_directorio <- survey_raw %>%
  group_by(directorio) %>%
  summarize(count_entry = n(),count_na = sum(is.na(cod_upz_grupo))) %>%
  mutate(percentage_entry = count_entry / nrow(survey_raw) * 100) %>%
  mutate(control = ifelse(count_entry == count_na,"All na's", "None")) %>%
  mutate(diff = count_entry - count_na) %>%
  arrange((diff))

entry_by_directorio
```

Filter equal values

```{r}
entry_by_directorio_control <- filter(entry_by_directorio, control == "None") %>%
  mutate(control_diff = diff==count_entry)

unique(entry_by_directorio_control$control_diff)
```

All entries, either have all NA's value per "directorio" or none.

Missing ZPU

```{r}
filter(survey_raw, is.na(cod_upz_grupo))

```

##### Example

directorio = "220102"

```{r}
filter(survey_raw, directorio == "220102") %>%
  dplyr::select(directorio,directorio_per, directorio_hog, # ID
         cod_upz_grupo, # ZPU code
         nombre_upz_grupo, # ZPU name
         orden, # Order in home
         npcep4, # Age
         npcep6, # Relation to Household leader
         npcep11a) # Place of birth
```

#### Additional variables

Data type

```{r}
Datatypelist_survey_add <- survey_add_raw %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist_survey_add
```

##### Profiling

Summary

```{r}
introduce(survey_add_raw)
```

Missing values

```{r}
plot_missing(survey_raw)
```

Missing values on ID fields

```{r}
survey_add_raw %>% dplyr::select(directorio, directorio_per, directorio_hog) %>%
  plot_missing(.)

```

##### Example

directorio = "220102"

```{r}
filter(survey_add_raw, directorio == "220102") %>%
  dplyr::select(
    directorio,directorio_per, # ID
    N_fuerza_trabajo, # In labour market
    N_informal, # Informal
    N_analfabeta, # Illiterate
    N_pobre_ipm, # MPI poor
    N_codigo_upz_trabajo, # ZPU ID of workplace
    N_INGTOT_PER, # Total income 
    N_pobre_monetario) # Monetary poverty
```

# Land use (in progress)

## Data reading

```{r}
land_use_terrain <- st_read("Data/Raw/Land_use/Terrain/DestinoSHP/Destino.shp")
```
Geometry

```{r}
# qtm(land_use_terrain)
```

Invalid poligons

## Data inspection

CRS

```{r}
st_crs(land_use_terrain)
```

Set the polygon object in WGS84 CRS

```{r}
land_use_terrain84 <- land_use_terrain %>%
  st_set_crs(.,4326)
```

New CRS


```{r}
st_crs(land_use_terrain84)
```

## Data cleaning

Invalid geometries

```{r}
invalid_geo_land_use <- st_is_valid(land_use_terrain84, reason = TRUE)
```

Clean geometry

```{r}
land_use_terrain84_clean <- st_make_valid(land_use_terrain84)
```


Map

```{r}
qtm(land_use_terrain84_clean)
```





# Elevation data (Not included yet)

Elevation data on every ZPU polygon

**Should be calculated for the H3 hegagon grid**

```{r}
# elevation <- get_elev_raster(geo_zpu, z = 9)
```

```{r}
# elevation
```

Plotting test

```{r}
# plot(elevation)
# plot(geo_zpu, add = TRUE)
```

## Data cleaning (pending,remove?)

# Preprocessing

## Spatial analysis unit

H3 hexagonal grid

Set the polygon object in WGS84 CRS

```{r}
geo_zpu_wgs84 <- geo_zpu %>%
  st_transform(.,4326)
```

New CRS

```{r}
st_crs(geo_zpu_wgs84)
```
Dissolve polygons

```{r}
geo_zpu_wgs84_mono <- st_union(geo_zpu_wgs84, by_feature = FALSE)
```


### Hegagonal grid

#### Resolution 9

Intersecting grids

```{r}
intergrid_9 <- polyfill(geo_zpu_wgs84_mono, res = 9)
```
H3 id to sf

```{r}
hex_grid_9<- h3_to_geo_boundary_sf(intergrid_9)
```

Basic geo map

```{r}
ggplot() +
  geom_sf(data = hex_grid_9) +
  theme_minimal()
```
There are holes in the grid with a 9 resolution.

#### Resolution 8

Intersecting grids

```{r}
intergrid_8 <- polyfill(geo_zpu_wgs84_mono, res = 8)
```
H3 id to sf

```{r}
hex_grid_8 <- h3_to_geo_boundary_sf(intergrid_8)
```

Basic geo map

```{r}
ggplot() +
  geom_sf(data = hex_grid_8) +
  theme_minimal()
```

There are not holes with 8 resolution value.



## Data enrichment


### Survey

#### Main forms

#### Additional variables (pending)

Aggregation of additional variables data by ZPU

```{r}
# survey_add_raw_clean <- survey_add_raw %>%
  
```

Erase entries with Na ZPU id field.

```{r}

```

### Land use

Spatial join between hexagon grid and land use layer

```{r}
# hex9_land_use_join <- st_join(hex_grid_9, land_use_terrain84_clean, join = st_intersects )
```



Pivot wide by land use category

```{r}
# hex9_land_use_join_wide <- hex9_land_use_join %>%
# 
#   group_by(h3_index, DESTINOCOD) %>%
#   summarize(count_land_use_code = n())  %>%
#   pivot_wider(names_from = "DESTINOCOD", values_from = "count_land_use_code", values_fill = 0 , names_prefix = "LU_COD_")
# 
# 
#   
```
Review

```{r}
# head(hex9_land_use_join_wide)
```
Dropping geometry column

```{r}
# hex9_land_use_join_wide <- hex9_land_use_join_wide %>%
#   dplyr::select(!geometry) %>%
#   st_drop_geometry(.)
```


Review

```{r}
# head(hex9_land_use_join_wide)
```

Merge with initial hexagon grid

```{r}
# hex9_land_use_final <- merge(hex_grid_9, hex9_land_use_join_wide, by.x = "h3_index", by.y = "h3_index", all.x = TRUE)

```

Saving hexagon grid

__It does not include demographics data yet__

```{r}
# hex9_land_use_final %>%
#   st_write("Data/Preprocessed/Grid/Hex9_grid.gpkg",
#            "Hex9_LU",
#            delete_layer=TRUE)
```

Reading from preprocessed directory

```{r}
hex9_land_use_final <- st_read("Data/Preprocessed/Grid/Hex9_grid.gpkg","Hex9_LU")
```


Review

```{r}
head(hex9_land_use_final)
```
Plotting

```{r}
ggplot(hex9_land_use_final) +
  ggtitle("Opportunities") + 
  geom_sf(aes(fill = LU_COD_21), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "High Street Retail\nOpportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Opportunities_COD_21.png", path = "Data/Results/Images/")
```


## Origin and destination points

```{r}
hex9_points <- hex9_land_use_final %>%
  st_centroid() %>%
  rename(id = h3_index)
  
```

Geometry

```{r}
qtm(hex9_points)
```

Calculate lon and lat coordinates

```{r}
hex9_points$lon <- st_coordinates(hex9_points)[, 1]
hex9_points$lat <- st_coordinates(hex9_points)[, 2]
```

Drop geometry of hex grid

```{r}
hex9_points <- hex9_points %>% 
  st_drop_geometry() %>%
  relocate(lon, .after = id) %>%
  relocate(lat, .after = lon)
```

Save point data as csv

```{r}
# write.csv(hex9_points,file='Data/Preprocessed/Grid/Hex9_grid_LU.csv', row.names=FALSE)
```


# Spatial analysis (Pending)

# Accessiblity modelling

## Data preparation

Creates directory for accessibility analysis


```{r}
access_dir <- "Accessibility"
dir.create(access_dir)
```

Creates before and after directories

```{r}
before_dir <- file.path(access_dir, "Before")
metro_dir <- file.path(access_dir, "Metro")
after_dir <- file.path(access_dir, "After")

dir.create(before_dir)
dir.create(metro_dir)
dir.create(after_dir)

```

Copy input files to before directory

Before data

```{r}
# BRT GTFS data
file.copy(from = "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip", to = file.path(before_dir, "brt_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(before_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(before_dir, "hex9_points_LU.csv"))

```

Metro data

```{r}

# Metro GTFS data
file.copy(from = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", to = file.path(metro_dir, "metro_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(metro_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(metro_dir, "hex9_points_LU.csv"))


```
After data

```{r}

# BRT GTFS data
file.copy(from = "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip", to = file.path(after_dir, "brt_gtfs.zip"))

# Metro GTFS data
file.copy(from = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", to = file.path(after_dir, "metro_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(after_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(after_dir, "hex9_points_LU.csv"))
```


Visualize directory

```{r}
fs::dir_tree(access_dir)
```
## Parameters

Parameters value in accessibility modelling

```{r}
# Time travel parameters
ttm_global_cutoff <- 60 # minutes
ttm_max_walk_time <- 30 # minutes
ttm_max_trip_duration <- 60 # minutes


# R5R parameters
r5r_global_cutoff <- 60 # minutes
r5r_max_walk_time <- 30 # minutes
r5r_max_trip_duration <- 60 # minutes
```

## Walking mode

Considers just walking mode.

### Setup

```{r}
r5r_walk <- setup_r5("Accessibility/Before", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Before/hex9_points_LU.csv")
```


### Time travel matrix


```{r}
ttm_walk <- travel_time_matrix(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_walk, "travel_time_p50", "travel_time")
```

Creates a time matrix object

```{r}
main_ttm_hex9 <- rename(ttm_walk, walk_tt = travel_time)
```

### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_walk <- cumulative_cutoff(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_walk)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_walk <- cost_to_closest(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_walk)
```
### R5R package

```{r}
r5r_access_walk <- accessibility(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_walk)
```
### Results comparison

Using accessibility package

```{r}
cum_cutoff_walk <- cumulative_cutoff(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_walk <- merge(
  r5r_access_walk,
  cum_cutoff_walk,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_walk,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_walk[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution

Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  hex_grid_9,
  r5r_access_walk,
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_walk_30 = accessibility)
```

Drop cutoff and percentile column

```{r}
main_results_hex9 <- main_results_hex9 %>%
  dplyr::select(!c(cutoff,percentile))
```
Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_brt) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```


Regular Vidiris color scheme

```{r}
plot_title <- paste("Walking accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  ggtitle(plot_title) +
  geom_sf(aes(fill = b_walk_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Walk_base.png", path = "Data/Results/Images/")
```

## Base scenario

It does not have the future metro data.

### Setup

```{r}
r5r_before <- setup_r5("Accessibility/Before", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Before/hex9_points_LU.csv")
```

### Time travel matrix

Without erasing geometries

```{r}
ttm_brt <- travel_time_matrix(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_brt, "travel_time_p50", "travel_time")
```

Merging

```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_brt,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, brt_tt = travel_time)
```


### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_brt <- cumulative_cutoff(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_brt)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_brt <- cost_to_closest(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_brt)
```

### R5R package

```{r}
r5r_access_brt <- accessibility(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK","BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_brt)
```

### Results comparison

Using accessibility package

```{r}
cum_cutoff_brt <- cumulative_cutoff(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_brt <- merge(
  r5r_access_brt,
  cum_cutoff_brt,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_brt,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_brt[, .(id, r5r_access, accessibility_access)])
```

Results consistent across methods.

### Spatial distribution


Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_brt[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_brt_30 = accessibility)
```

Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_brt) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```


Regular Vidiris color scheme

```{r}

plot_title <- paste("BRT accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = b_brt_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("BRT_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not ar use)

```{r}
# main_results_hex9 %>%
#   st_write("Data/Results/Before/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_brt",
#            delete_layer=TRUE)
```



## Metro only scenario

### Setup

```{r}
r5r_metro <- setup_r5("Accessibility/Metro", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Metro/hex9_points_LU.csv")
```

### Inputs review




### Time travel matrix

Without erasing geometries

```{r}
ttm_metro <- travel_time_matrix(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "SUBWAY"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_metro, "travel_time_p50", "travel_time")
```


Merge

```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_metro,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, metro_tt = travel_time)
```


### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_metro <- cumulative_cutoff(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_metro)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_metro <- cost_to_closest(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_metro)
```

### R5R package

```{r}
r5r_access_metro <- accessibility(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK", "SUBWAY"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_metro)
```

### Results comparison

Using accessibility package

```{r}
cum_cutoff_metro <- cumulative_cutoff(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_metro <- merge(
  r5r_access_metro,
  cum_cutoff_metro,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_metro,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_metro[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_metro[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, m_metro_30 = accessibility)
```


Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_metro) +
#   ggtitle("Metro accessibility: cutoffs = 30  max_walk_time = 30, max_trip_duration = 120") +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   #theme_minimal()
#   theme(plot.title = element_text(size = 8, face = "bold"))
# 
# ggsave("Metro.png", path = "Data/Results/Images/")
```


Regular Vidiris color scheme

```{r}

plot_title <- paste("Metro accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  ggtitle(plot_title) +
  geom_sf(aes(fill = m_metro_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Metro_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not in use, write just at the end)

```{r}
# spatial_r5r_metro %>%
#   st_write("Data/Results/Metro/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_metro",
#            delete_layer=TRUE)
```

## BRT and metro scenario

### Setup

```{r}
r5r_after <- setup_r5("Accessibility/After", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/After/hex9_points_LU.csv")
```

### Time travel matrix

Without erasing geometries

```{r}
ttm_full <- travel_time_matrix(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_full, "travel_time_p50", "travel_time")
```

Merging ttm results


```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_full,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, brt_metro_tt = travel_time)
```



### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_full <- cumulative_cutoff(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_full)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_full <- cost_to_closest(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_full)
```

### R5R package

```{r}
r5r_access_full <- accessibility(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_full)
```
### Results comparison

Using accessibility package

```{r}
cum_cutoff_full <- cumulative_cutoff(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_full <- merge(
  r5r_access_full,
  cum_cutoff_full,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_full,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_full[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution

Merging accessibility results with hexagon grid

```{r}
# spatial_r5r_full <- merge(
#   hex_grid_9,
#   r5r_access_full,
#   by.x = "h3_index",
#   by.y = "id"
# )
```

Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_full[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, a_brt_metro_30 = accessibility)
```


Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_full) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```

Regular Vidiris color scheme

```{r}
plot_title <- paste("BRT and Metro accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)



ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = a_brt_metro_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("BRT_Metro_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not in use, save at the end)

```{r}
# spatial_r5r_full %>%
#   st_write("Data/Results/After/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_full",
#            delete_layer=TRUE)
```

## Time travel matrix

Time travel matrix review

Head

```{r}
head(main_ttm_hex9)
```

Summary

```{r}
summary(main_ttm_hex9)
```
### Variations

```{r}
main_ttm_hex9 <- main_ttm_hex9 %>%
  mutate(
    diff_walk_metro = metro_tt - walk_tt,
    diff_walk_brt = brt_tt - walk_tt,
    diff_brt_brt_metro = brt_metro_tt - brt_tt)
```

Summary after variations

```{r}
summary(main_ttm_hex9)
```
Groping results by origin hexagon

```{r}
sta_diff_ttm_hex9 <- main_ttm_hex9 %>%
  group_by(from_id) %>%
  summarise(across(contains("diff"), list(
    Min = min,
    Max = max,
    Mean = mean,
    Median = median,
    SD = sd
  )))
```

Merging statistic results with hexagon matrix

```{r}
geo_sta_diff_ttm_hex9 <- merge(
  hex_grid_9,
  sta_diff_ttm_hex9,
  by.x = "h3_index",
  by.y = "from_id"
)
```

Plotting differences

Walking vs BRT

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs BRT") + 
  geom_sf(aes(fill = diff_walk_brt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median walking time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_Walk_BRT.png", path = "Data/Results/Images/")
```


Walking vs Metro


```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs Metro") + 
  geom_sf(aes(fill = diff_walk_metro_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median walking time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_Walk_Metro.png", path = "Data/Results/Images/")
```


BRT vs BRT + Metro

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: BRT vs BRT + Metro") + 
  geom_sf(aes(fill = diff_brt_brt_metro_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median walking time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_BRT_BRT_Metro.png", path = "Data/Results/Images/")
```



### Extreme cases

#### Descriptive statistics

Descriptive statistics of ttm by mode

```{r}
sta_ttm_hex9 <- main_ttm_hex9 %>%
  group_by(from_id) %>%
  summarise(across(contains("tt"), list(
    Min = min,
    Max = max,
    Mean = mean,
    Median = median,
    SD = sd
  )))
```

Merging statistic results with hexagon matrix

```{r}
geo_sta_ttm_hex9 <- merge(
  hex_grid_9,
  sta_ttm_hex9,
  by.x = "h3_index",
  by.y = "from_id"
)
```

#### Plotting modes

Median walking time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = walk_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median walking time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median BRT time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = brt_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median BRT time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median Metro time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = metro_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median Metro time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median BRT + Metro time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = brt_metro_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median BRT + Metro time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

### Walk

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == max(walk_tt))
```
Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == min(walk_tt))
```


### BRT

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_tt == max(brt_tt))
```

Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == min(walk_tt))
```



### Metro

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(metro_tt == max(metro_tt))
```

Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(metro_tt == min(metro_tt))
```

### BRT + Metro

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_metro_tt == max(brt_metro_tt))
```
Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_metro_tt == min(brt_metro_tt))
```


### Sampled examples (pending)

Review of consistency of merge and values of ttm values across scenarios








## Parameters

### Duration thresholds

```{r}
# R5R parameters
r5r_1_global_cutoff <- 120 # minutes
r5r_1_max_walk_time <- 60 # minutes
r5r_1_max_trip_duration <- 120 # minutes
```


#### Walking 

##### R5R package


```{r}
r5r_access_walk_1 <- accessibility(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

##### Spatial distribution


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_walk_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_walk_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}
plot_title <- paste("Walking accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)


ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = b_walk_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Walk_C1.png", path = "Data/Results/Images/")
```


#### BRT

##### R5R package

```{r}
r5r_access_brt_1 <- accessibility(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid (not in use)

```{r}
# spatial_r5r_brt_1 <- merge(
#   hex_grid_9,
#   r5r_access_brt_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_brt_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_brt_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}

plot_title <- paste("BRT accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)



ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = b_brt_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("BRT_C1.png", path = "Data/Results/Images/")
```
#### Metro

##### R5R package

```{r}
r5r_access_metro_1 <- accessibility(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "TRANSIT"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid

```{r}
# spatial_r5r_metro_1 <- merge(
#   hex_grid_9,
#   r5r_access_metro_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```


Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_metro_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, m_metro_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}
plot_title <- paste("Metro accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)



ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = m_metro_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Metro_C1.png", path = "Data/Results/Images/")
```
#### BRT + Metro

##### R5R package

```{r}
r5r_access_full_1 <- accessibility(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid (not in use)

```{r}
# spatial_r5r_full_1 <- merge(
#   hex_grid_9,
#   r5r_access_full_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```

Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_full_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, a_brt_metro_x = accessibility)
```


Plotting


Regular Vidiris color scheme

```{r}

plot_title <- paste("BRT and Metro accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)


ggplot(main_results_hex9) +
  ggtitle(plot_title) + 
  geom_sf(aes(fill = a_brt_metro_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("BRT_Metro_C1.png", path = "Data/Results/Images/")
```


## Global measure comparison

### Summary

```{r}
summary(main_results_hex9)
```

### Write geopackage

```{r}
main_results_hex9 %>%
  st_write("Data/Results/After/Grid/Hex9_grid.gpkg",
           "Hex9_r5r_full",
           delete_layer=TRUE)
```


## Hexagon measure comparison



## Alternative scenario
