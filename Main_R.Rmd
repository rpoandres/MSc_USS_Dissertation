---
title: "Accessibility impact of transport infrastructure: Spatial assessment of Bogota's future metro system"
author: "Andrés Restrepo Jiménez"
date: '2023-06-19'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

```{r}
library(r5r)
library(accessibility)
library(ggplot2)
library(ggspatial)
library(aopdata)
library(gtfstools)
library(readr)
library(dplyr)
library(tidyr)
library(st)
library(httr)
library(sf)
library(patchwork)
library(tmap)
library(tmaptools)
library(forcats)
library(scales)
library(writexl)
library(DataExplorer)
library(osmextract)
library(osmdata)
library(leaflet) # for making the interactive map
library(elevatr) # DEM (Digital Elevation Model)
library(raster)
library(h3jsr) # H3 hegagonal grid
library(remotes)
library(h3)
library(lubridate) # date data management
library(hms) # date data management
library(zip)
library(viridis)
library(xtable)
library(RColorBrewer)
```

## Temporary directory

Location to store temporary data.

```{r}
tempdir()
```

Deletes temporary directory.

```{r}
# unlink(tempdir(), recursive = TRUE)
```

## Memory setup

Setup is required to run the accessibility modelling procedure.

```{r}
options(java.parameters = "-Xmx4G")
```

# Bus Rapid Transit network (BRT)

This section aims to review and process he GTFS dta from the BRT operation in Bogota.

## Downloading the data (turn off)

This is section is not operational, instead the data will be read locally.

Setting the temp file path

```{r}
# brt_path <- tempfile("brt", fileext = ".zip")
```

Downloading the BRT GTFS data

```{r}
# httr::GET(
#   "https://storage.googleapis.com/gtfs-estaticos/GTFS-2023-06-21.zip",
#   httr::write_disk(brt_path)
# )
```

Initial: The GTFS data is a static feed (2021-07-04) provided by the Transport Secretary of Bogota City Council available [here](https://datos.movilidadbogota.gov.co/datasets/599751603a494051b15ac3d4f1f38ec5/about).

Update: The data was updated with static feed (2023-06-21) provided by Transmilenio in their open data webpage and available [here](https://datosabiertos-transmilenio.hub.arcgis.com/documents/gtfs-est%C3%A1ticos-2023-06-21/about).


Review of tables of downloaded data

```{r}
# unzip(brt_path, list = TRUE)
```


```{r}
# brt_gtfs <- read_gtfs(brt_path)
# 
# names(brt_gtfs)
```

## Reading data locally


Reading data locally

```{r}
brt_gtfs <- read_gtfs("Data/Raw/Transport/BRT/GTFS-2023-06-21.zip")

names(brt_gtfs)
```

## Data inspection

### Summary

```{r}
summary(brt_gtfs)
```

### Validation

```{r}
# validate_gtfs(
#   "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip",
#   output_path = "Data/Raw/Transport/BRT/Validation/",
#   validator_path = download_validator(tempdir())
# )
```


### Profiling

```{r}
plot_str(brt_gtfs)
```

### Agency

```{r}
head(brt_gtfs$agency)
```

Data type

```{r}
Datatypelist_brt_agency <- brt_gtfs$agency %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_brt_agency
```


### Routes

```{r}
head(brt_gtfs$routes)
```

#### Id

Number of rows in route table.

```{r}
nrow(brt_gtfs$routes)
```

Number of route id's.

```{r}
n_distinct(brt_gtfs$routes$route_id)
```


#### Description

Number of descriptions

```{r}
n_distinct(brt_gtfs$routes$route_desc)
```

Description texts

```{r}
unique(brt_gtfs$routes$route_desc)
```

Filtering route id by desc value

##### Main corredor

```{r}
route_id_main <- filter(brt_gtfs$routes,  route_desc == "TRONCAL") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_main <- filter_by_route_id(brt_gtfs, route_id_main$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_main <- gtfstools::get_trip_geometry(brt_gtfs_main, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_main <- geo_shapes_main %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_main$route_desc <- "Main"
```


##### Urban

```{r}
route_id_urban <- filter(brt_gtfs$routes,  route_desc == "URBANO") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_urban <- filter_by_route_id(brt_gtfs, route_id_urban$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_urban <- gtfstools::get_trip_geometry(brt_gtfs_urban, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_urban <- geo_shapes_urban %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_urban$route_desc <- "Urban"
```


##### Feeder

```{r}
route_id_feeder <- filter(brt_gtfs$routes,  route_desc == "ALIMENTADOR") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_feeder <- filter_by_route_id(brt_gtfs, route_id_feeder$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_feeder <- gtfstools::get_trip_geometry(brt_gtfs_feeder, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_feeder <- geo_shapes_feeder %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_feeder$route_desc <- "Feeder"
```


##### Feeder_V

```{r}
route_id_feeder_v <- filter(brt_gtfs$routes,  route_desc == "ALIMENTADOR_V") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_feeder_v <- filter_by_route_id(brt_gtfs, route_id_feeder_v$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_feeder_v <- gtfstools::get_trip_geometry(brt_gtfs_feeder_v, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_feeder_v <- geo_shapes_feeder_v %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_feeder_v$route_desc <- "Feeder"
```

##### Complementary

```{r}
route_id_comp <- filter(brt_gtfs$routes,  route_desc == "COMPLEMENTARIO") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_comp <- filter_by_route_id(brt_gtfs, route_id_comp$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_comp <- gtfstools::get_trip_geometry(brt_gtfs_comp, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_comp <- geo_shapes_comp %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_comp$route_desc <- "Complementary"
```


##### Special

```{r}
route_id_special <- filter(brt_gtfs$routes,  route_desc == "ESPECIAL") %>%
  dplyr::select(route_id)
```

Subset GTFS data by route id

```{r}
brt_gtfs_special <- filter_by_route_id(brt_gtfs, route_id_special$route_id, keep = TRUE)
```

Geometry of subsetted routes

```{r}
geo_shapes_special <- gtfstools::get_trip_geometry(brt_gtfs_special, file = "shapes")
```

Remove duplicated geometries

```{r}
geo_shapes_special <- geo_shapes_special %>%
  group_by(geometry) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Create route type id field

```{r}
geo_shapes_special$route_desc <- "Special"
```


##### Saving 

```{r}
# # Main
# geo_shapes_main %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Main",
#            delete_layer=TRUE)
# 
# geo_shapes_urban %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Urban",
#            delete_layer=TRUE)
# 
# geo_shapes_feeder %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Feeder",
#            delete_layer=TRUE)
# 
# geo_shapes_feeder_v %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#             "Feeder_v",
#             delete_layer=TRUE)
# 
# geo_shapes_comp %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Complementary",
#            delete_layer=TRUE)
# 
# geo_shapes_special %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Special",
#            delete_layer=TRUE)




```


#### Type

Number of types

```{r}
n_distinct(brt_gtfs$routes$route_type)
```

Type texts

```{r}
unique(brt_gtfs$routes$route_type)
```

Consistent with official GTFS [specification](https://gtfs.org/schedule/reference/#routestxt).

### Trips

```{r}
head(brt_gtfs$trips)
```


Number of routes in table

```{r}
n_distinct(brt_gtfs$trips$route_id)
```

Number of uniques entries

```{r}
n_distinct(brt_gtfs$trips)
```


#### Case 1

In order to demographically display and review the routes, a set of routes is selected.

Routes: Z_7295 and Z_7295-2.

```{r}
brt_gtfs_trip_c1 <- filter_by_route_id(brt_gtfs, c("Z_7295", "Z_7295-2") , keep = TRUE)
```

Get geometry

```{r}
geo_brt_gtfs_trip_c1 <- gtfstools::get_trip_geometry(brt_gtfs_trip_c1, file = "shapes")
```

Plot

```{r}
qtm(geo_brt_gtfs_trip_c1)
```

Stop times

```{r}
View(brt_gtfs_trip_c1$stop_times)
```


### Stops

```{r}
head(brt_gtfs$stops)
```

Number of stations

```{r}
n_distinct(brt_gtfs$stops)
```

Convert stops to sf

```{r}
brt_stations_sf <- st_as_sf(brt_gtfs$stops,coords = c("stop_lon", "stop_lat"), crs = 4326 )
```

Plot stations

```{r}
brt_stations_sf %>%
  st_geometry() %>%
  plot()
```

Basic geo map

```{r}
ggplot() +
  geom_sf(data = brt_stations_sf) +
  theme_minimal()
```

#### Id

Number of rows in station table

```{r}
n_distinct(brt_gtfs$stops$stop_id)
```


#### Stop code

Number of rows in station table

```{r}
n_distinct(brt_gtfs$stops$stop_code)
```

Stop code and stop id seem to be equivalent.

### Calendar



```{r}
head(brt_gtfs$calendar)
```

Data type

```{r}
Datatypelist_brt_calendar <- brt_gtfs$calendar %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_brt_calendar
```

### Calendar dates

```{r}
head(brt_gtfs$calendar_dates)
```

Number of exceptions

```{r}
n_distinct(brt_gtfs$calendar_dates)
```

#### Exception type

Exeption_type: "Indicates whether service is available on the date specified in the date field.

Valid options are:

1 - Service has been added for the specified date. 2 - Service has been removed for the specified date."

```{r}
unique(brt_gtfs$calendar_dates$exception_type)
```

Number of different dates in calendar dates

```{r}
unique(brt_gtfs$calendar_dates$date)
```

It seems to be holidays in Colombia.

#### Service id

```{r}
n_distinct(brt_gtfs$calendar_dates$service_id)
```



### Shapes

```{r}
head(brt_gtfs$shapes)
```

Number of shapes entries in table

```{r}
n_distinct(brt_gtfs$shapes$shape_id)
```

Number of unique entries

```{r}
n_distinct(brt_gtfs$shapes)
```

#### Geometry

Getting geometry from new data

```{r}
geo_shapes <- gtfstools::get_trip_geometry(brt_gtfs, file = "shapes")
```

The new object is already a sf object.

Review

```{r}
head(geo_shapes)
```

###### Saving

Saving shapes as geopackage (not working)

```{r}
# geo_shapes %>%
#   st_write("Data/Preprocessed/BRT/Network/BRT_Network.gpkg",
#            "Complete_Network",
#            delete_layer=TRUE)
```

Plotting geometry only (not working)

```{r}
# geo_shapes %>%
#   st_geometry() %>%
#   plot()
```

Basic geo map (not working)

```{r}
# ggplot() +
#   geom_sf(data = geo_shapes) +
#   theme_minimal()
```

##### Sample of geometries

Given the high volume of routes, a fixed number is selected for plotting purposes.

```{r}
set.seed(123) 

sample <- sample(brt_gtfs$trips$trip_id,1000)

head(sample)
```

Subsetting geometries

```{r}
geo_shapes_sample<- gtfstools::get_trip_geometry(brt_gtfs,file = "shapes", trip_id = sample)
```


```{r}
head(geo_shapes_sample)
```

Plotting sample geometries

```{r}
ggplot() +
  geom_sf(data = geo_shapes_sample) +
  theme_minimal()
```


##### Check for valid geometries

```{r}
unique(st_is_valid(geo_shapes))
```

There are invalid geometries in the new data.

##### Empty geometries (not working)

```{r}
unique(st_is_empty(geo_shapes))
```

There are not empty geometries in new data set.

##### Remove invalid geometries (not used in new data set)

```{r}
# invalid_geometries <- !st_is_valid(geo_from_stops_filtered)
# 
# geo_from_stops_filtered <- geo_from_stops_filtered[invalid_geometries == FALSE, ]
```


### Stops times

```{r}
summary(brt_gtfs$stop_times)
```

```{r}
head(brt_gtfs$stop_times)
```

```{r}
brt_gtfs$stop_times
```

Filter stop sequence 0 values

```{r}
filter(brt_gtfs$stop_times, stop_sequence == 0)
```

Initial data: Count of 0 stop sequence values. New data: Zero entries with 0 value in stop sequence field.

```{r}
stop_cero_sequence <- filter(brt_gtfs$stop_times, stop_sequence == 0) %>%
  group_by(stop_id) %>%
  summarize(count_cero = n()) #%>%

stop_cero_sequence <- stop_cero_sequence[order(desc(stop_cero_sequence$count_cero)),]

```

Blank output.

#### Trip Id

```{r}
n_distinct(brt_gtfs$stop_times$trip_id)
```

Sorting by trip id

```{r}
brt_gtfs$stop_times[order(trip_id)]
```


#### Stop sequence

Unique value in stop_sequence field

```{r}
n_distinct(brt_gtfs$stop_times$stop_sequence)
```

Histogram on stop sequence values

```{r}
histo_stop_sequence <- ggplot(brt_gtfs$stop_times, aes(x=stop_sequence)) +
  ggtitle("Histogram of stop sequence values") + 
  geom_histogram() + xlab("Stop sequence")
histo_stop_sequence
```

Multiple stations with "1" values in the stop sequence.

Filter entries with zero values in stop time stop sequence field

```{r}
filter(brt_gtfs$stop_times, stop_sequence==0)
```

Zero entries with zero value in the stop sequence field


##### Case 1

In order to individually review the route geometries, a set of cases is selected.

Two stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BC42D0021-04-2_T_1785")
```

Review of individual geometry

```{r}
geo_case_1 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BC42D0021-04-2_T_1785")
```

The new object is already a sf object.

Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_1) +
  theme_minimal()
```

Although, there are only 2 points, with the shape table data, the geometry output shows a smooth route.

##### Case 2

Tree stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BO7ED0007-02-2_T_2192")
```

Review of individual geometry

```{r}
geo_case_2 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BO7ED0007-02-2_T_2192")
```

Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_2) +
  theme_minimal()
```

##### Case 3

Four stops

```{r}
filter(brt_gtfs$stop_times, trip_id == "BCGIA0007-13-3_Z_6441")
```

Same example with -2 suffix

```{r}
filter(brt_gtfs$stop_times, trip_id == "BCGIA0007-13-3_Z_6441-2")
```

Review of individual geometry

```{r}
geo_case_3 <- gtfstools::get_trip_geometry(brt_gtfs, trip_id = "BCGIA0007-13-3_Z_6441")
```


Plotting geometry only

```{r}
ggplot() +
  geom_sf(data = geo_case_3) +
  theme_minimal()
```


### Frequencies (blank)

The absence of this table does not represent an obstacle as it is optional considering that there is the stop_times table.

```{r}
head(brt_gtfs$frequencies)
```

```{r}
brt_gtfs$frequencies
```

There is no data in the frequencies table.

### Fare attributes

```{r}
head(brt_gtfs$fare_attributes)
```

```{r}
brt_gtfs$fare_attributes
```

Types of fare (price) information by agency.

Transfers
1. 0 indicate no transfers permitted.
NA. indicates Unlimited transfers are permitted.

### Fare rules

```{r}
head(brt_gtfs$fare_rules)
```

```{r}
brt_gtfs$fare_rules
```

#### Fare id

```{r}
unique(brt_gtfs$fare_rules$fare_id)
```

#### Route id

```{r}
length(unique(brt_gtfs$fare_rules$route_id))
```

Fare information for 1086 routes.


### Route detailed review

Case 1 is reviewed in detail.

#### Case 1

Route 6-4, "6-4" in route id field with id 

```{r}
brt_gtfs_C1_1 <- filter_by_route_id(brt_gtfs, "T_1899", keep = TRUE)
```

##### Route

```{r}
brt_gtfs_C1$routes
```
##### Trips

```{r}
brt_gtfs_C1$trips
```

Schedule: Monday to Friday.

Number of trips

```{r}
length(unique(brt_gtfs_C1$trips$trip_id))
```
There are 666 trips for this route.

##### Shapes

```{r}
brt_gtfs_C1$shapes
```

Geometry

```{r}
geo_brt_gtfs_C1 <- gtfstools::get_trip_geometry(brt_gtfs_C1,file = "shapes")
```

Review

```{r}
geo_brt_gtfs_C1
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_brt_gtfs_C1) +
  theme_minimal()
```

##### Stops

```{r}
brt_gtfs_C1$stops
```

Convert stops to sf

```{r}
geo_brt_stations_C1_sf <- st_as_sf(brt_gtfs_C1$stops,coords = c("stop_lon", "stop_lat"), crs = 4326)
```

Plot stations

```{r}
geo_brt_stations_C1_sf %>%
  st_geometry() %>%
  plot()
```

##### Stop times

```{r}
arrange(brt_gtfs_C1$stop_times, trip_id, stop_sequence)
```

##### Fare attribute

```{r}
brt_gtfs_C1$fare_attributes
```

##### Fare rules

```{r}
brt_gtfs_C1$fare_rules
```

##### Plotting

```{r}
ggplot() +
  geom_sf(data = geo_brt_stations_C1_sf) + 
  geom_sf(data = geo_brt_gtfs_C1) + 
  theme_minimal()
```

###### Case 1 - 1

A specific trip is filtered by id.

```{r}
brt_gtfs_C1_1 <- filter_by_trip_id(brt_gtfs, "BC4290001-02-3_T_1899", keep = TRUE)
```


###### Testing track and stations and track overlap in brt case

Routes

```{r}
brt_gtfs_C1_1$routes
```
Trips

```{r}
brt_gtfs_C1_1$trips
```
Shape

```{r}
brt_gtfs_C1_1$shapes
```

Geometry

```{r}
geo_brt_gtfs_C1_1 <- gtfstools::get_trip_geometry(brt_gtfs_C1_1,file = "shapes")
```

Review

```{r}
geo_brt_gtfs_C1_1
```
Stops

```{r}
brt_gtfs_C1_1$stops
```

Convert stops to sf

```{r}
geo_brt_stations_C1_1_sf <- st_as_sf(brt_gtfs_C1_1$stops,coords = c("stop_lon", "stop_lat"), crs = 4326)
```

Plot stations

```{r}
geo_brt_stations_C1_1_sf %>%
  st_geometry() %>%
  plot()
```
Stop time

```{r}
arrange(brt_gtfs_C1_1$stop_times, trip_id, stop_sequence)
```


```{r}
inter_brt_stops_shape_1 <- st_intersection(geo_brt_stations_C1_1_sf,geo_brt_gtfs_C1_1)
```

Review

```{r}
inter_brt_stops_shape_1
```

Plotting

```{r}
ggplot() +
  geom_sf(data = inter_brt_stops_shape_1) +
  theme_minimal()
```



## Mapping

### Appeding

Appending different sf object

```{r}
geo_shapes_complete <- bind_rows(geo_shapes_main, geo_shapes_urban, geo_shapes_feeder,geo_shapes_feeder_v, geo_shapes_special, geo_shapes_comp)
```


### Plotting

General

```{r}
ggplot() +
  geom_sf(data = geo_shapes_complete, aes(color= route_desc), alpha = 0.8) +
  ggtitle("Bus Rapit Transit system", subtitle = "Routes by type")+
  theme(panel.grid.major = element_line(color = gray(0.5), linetype = "dashed",size = 0.5),panel.background = element_rect(fill = "aliceblue")) +
  xlab("Longitude") + ylab("Latitude") + 
  annotation_scale(location = "br", width_hint = 0.2)
  #theme_minimal()
```

Plot by route type

Levels

```{r}
geo_shapes_complete$route_desc <- factor(geo_shapes_complete$route_desc, levels = c("Main","Feeder", "Urban", "Complementary", "Special"))
```


Plot

```{r}
ggplot() +
  geom_sf(data = geo_shapes_complete, aes(color= route_desc), alpha = 0.8) +
  facet_wrap(
    ~ route_desc,
    nrow = 1)  + theme(legend.position = "none",
        axis.title = element_blank(),  # Remove axis titles
        axis.text = element_blank(),   # Remove axis labels
        axis.ticks = element_blank()) #+ theme_minimal()
# + ggtitle("Bus Rapit Transit system", subtitle = "Routes by type")

ggsave("BRT_Network_Route.png", path = "Data/Results/Images/")
```


# OSM network

In order to have a proxy of the pedestrian infrastructure, the vehicle infrastructures is used and taken from Open Street Map. This infrastructure is required to model the walking mode in the accessibility modelling procedure.

## Data reading

Open Street Map Data downloaded from: <https://export.hotosm.org/es/v3/>

```{r}
osm_network <- oe_read("Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf") 
```

### Plotting

General

```{r}
par(mar = rep(0.001, 4))
plot(sf::st_geometry(osm_network))
```
Subsetting

ZPU box

xmin: -74.22358 ymin: 4.45786 xmax: -74.00978 ymax: 4.830661

```{r}
ggplot() +
  geom_sf(data = osm_network, alpha = 0.3) +
  coord_sf(xlim = c(-74.2259, -74.00978), ylim = c(4.45786, 4.830661))

ggsave("OSM_Network.png", path = "Data/Results/Images/")
```


## Data inspection

### CRS

```{r}
st_crs(osm_network)
```

### Profilling

```{r}
plot_missing(osm_network)
```

Filter by highway value

```{r}
osm_by_highway<- osm_network %>%
  group_by(highway) %>%
  summarize(count_entry = n()) %>%
  arrange(desc(count_entry))
  

osm_by_highway
```

Plotting by highway value

```{r}
osm_subsetting <- osm_by_highway %>%
  filter(., highway == "residential")


par(mar = rep(0.1, 4))
plot(sf::st_geometry(osm_subsetting))
```


# Metro system

The following sections aims to create the GTFS data of the future metro system, based on the spatial features of the publicly available designs and the estimated travel speed. In order to model both metro and BRT transportation modes, the operations of both modes should be stored in GTFS format.

## GTFS data generation

Generates the main tables of the GTFS metro data.

### Agency

```{r}
metro_agency <- tibble::tribble(
  ~agency_id, ~agency_name, ~agency_url, ~agency_timezone, ~agency_lang, ~agency_phone,
  "1","Metro de Bogota","https://www.metrodebogota.gov.co/","America/Bogota","es", "(+57)601-555-33-33")

```

Generates table

```{r}
data.table::setDT(metro_agency)
```


### Routes

For the route creation, as there is only one metro line considered, a northbound and a southbound route will be created.

Create a metro route table

```{r}
metro_routes <- tibble::tribble(
  ~route_id,  ~route_short_name,~route_long_name, ~route_desc, ~agency_id, ~route_color, ~route_text_color, ~route_type,
  "M1_001", "S_001", "South", "Main", "1", "FFFFFF", "000000", "1",
  "M1_002", "N_001", "North", "Main", "1", "FFFFFF", "000000", "1")
```

Reads it as data frame

```{r}
data.table::setDT(metro_routes)
```


### Trips

The trip id field will follow the structure: ROUTEID_DIRECTION_SERVICEID_SHAPE_ID

DIRECTION:
N: North
S: South


```{r}
metro_trips <- tibble::tribble(
  ~route_id,  ~service_id,~trip_id, ~shape_id,
  "M1_001", "3", "M1_001_S_3_M1_001", "M1_001",
  "M1_002", "3", "M1_002_N_3_M1_002", "M1_002")
```

Reads it as a table

```{r}
data.table::setDT(metro_trips)
```


### Stops

Reading stations data of first line of metro.

```{r}
raw_metro_stations <- st_read("Data/Raw/Transport/Metro/Stations/ESTACIONES.shp") %>%
  st_transform(.,4326)
```
Review CRS

```{r}
st_crs(raw_metro_stations)
```

Geometry

```{r}
qtm(raw_metro_stations)
```

Calculates the centroids of every station polygon

```{r}
metro_stops <- raw_metro_stations %>%
  st_centroid() %>%
  rename(stop_name = RefName) %>%
  rename(stop_id = NOMBRE) %>%
  rename(stop_code = NUMERO)
  
```
Stops

```{r}
head(metro_stops)
```

Calculate longitude and latitude coordinates of centroids

```{r}
metro_stops$stop_lon <- st_coordinates(metro_stops)[, 1]
metro_stops$stop_lat <- st_coordinates(metro_stops)[, 2]

```

Adjust station code, populate location_type and zone_id

```{r}
metro_stops$location_type <- "0"
metro_stops$zone_id <- "0"
metro_stops$stop_id <- gsub("E", "M", metro_stops$stop_id)
```

Dropping columns and geometry and relocating columns

```{r}
metro_stops <- metro_stops %>%
  st_drop_geometry(.) %>%
  dplyr::select(!c(OBJECTID,TIPO, Shape_Leng, Shape_Area)) %>%
  relocate(stop_id) %>%
  relocate(stop_code, .after = stop_id) %>%
  relocate(stop_lat, .after = stop_name)
```

Ordering 

```{r}
metro_stops <- metro_stops[order(metro_stops$stop_code),]
```


### Calendar

Creating a mirror calendar table from the BRT GTFS data.

```{r}
metro_calendar <- brt_gtfs$calendar
```

Removes string characters

```{r}
metro_calendar$start_date <- gsub('-','',metro_calendar$start_date)
metro_calendar$end_date <- gsub('-','',metro_calendar$end_date)
```

### Calendar dates

Creating a mirror calendar date table from the BRT GTFS data (only for year 2022).

```{r}
metro_calendar_dates <- brt_gtfs$calendar_dates
```

"1 - Service has been added for the specified date. 
2 - Service has been removed for the specified date."

Removes string characters

```{r}
metro_calendar_dates$date <- gsub('-','',metro_calendar_dates$date)
```


### Shapes

Reading track data of first line of metro.

```{r}
raw_metro_line <- st_read("Data/Raw/Transport/Metro/Track/TRAZADO_PLMB.shp") %>%
  st_transform(.,4326)
```

Review CRS

```{r}
st_crs(raw_metro_line)
```

Geometry

```{r}
ggplot() +
  geom_sf(data = raw_metro_line) +
  theme_minimal()
```

#### Northbound shape

Create sf for northbound shape

```{r}
raw_metro_line_north <- raw_metro_line
```

Create shape id column

```{r}
raw_metro_line_north$shape_id = "M1_002"
```

Relocate columns

```{r}
raw_metro_line_north <- raw_metro_line_north  %>%
  relocate(shape_id)
```

Create shape table from sf object

```{r}
metro_shapes_north <- convert_sf_to_shapes(raw_metro_line_north, shape_id = NULL)
```

Sequence is build west to east in the shape table.

#### Southbound shape

Reverse raw geometry for southbound shape

```{r}
raw_metro_line_south <- st_reverse(raw_metro_line)
```

Create shape id column

```{r}
raw_metro_line_south$shape_id = "M1_001"
```

Relocate columns

```{r}
raw_metro_line_south <- raw_metro_line_south  %>%
  relocate(shape_id)
```

Create shape table from sf object

```{r}
metro_shapes_south <- convert_sf_to_shapes(raw_metro_line_south, shape_id = NULL)
```

#### Apending shapes

```{r}
metro_shapes <- bind_rows(metro_shapes_south,metro_shapes_north)
```

Droping columns

```{r}
metro_shapes <- metro_shapes %>%
  dplyr::select(!c(OBJECTID_1, OBJECTID, NOMBRE, Shape_Leng, z))
```

### Stops

Intersect with route geometry

```{r}
inter_metro_stops <- st_intersection(raw_metro_stations,raw_metro_line)
```
Plotting

```{r}
ggplot() +
  geom_sf(data = inter_metro_stops) +
  theme_minimal()
```

Calculates the centroids of every station line

```{r}
metro_stops <- inter_metro_stops %>%
  st_centroid() %>%
  rename(stop_name = RefName) %>%
  rename(stop_id = NOMBRE) %>%
  rename(stop_code = NUMERO)
  
```

Stops

```{r}
head(metro_stops)
```

Calculate longitude and latitude coordinates of centroids

```{r}
metro_stops$stop_lon <- st_coordinates(metro_stops)[, 1]
metro_stops$stop_lat <- st_coordinates(metro_stops)[, 2]

```

Adjust station code, populate location_type and zone_id fields

```{r}
metro_stops$location_type <- "0"
metro_stops$zone_id <- "0"
metro_stops$stop_id <- gsub("E", "M", metro_stops$stop_id)
```

Dropping columns and geometry and relocating columns

```{r}
metro_stops <- metro_stops %>%
  st_drop_geometry(.) %>%
  dplyr::select(!c(OBJECTID,TIPO, Shape_Leng, Shape_Area, OBJECTID_1,OBJECTID.1,NOMBRE.1,Shape_Leng.1)) %>%
  relocate(stop_id) %>%
  relocate(stop_code, .after = stop_id) %>%
  relocate(stop_lat, .after = stop_name)
```

Ordering 

```{r}
metro_stops <- metro_stops[order(metro_stops$stop_code),]
```


### Stop times

#### Distance calculation

Based on the location of each stations, the distance between them is calculated.

Point geometry

```{r}
metro_stations_points <- raw_metro_stations %>%
  st_centroid()
```
Sorting stations

```{r}
metro_stations_points <- metro_stations_points[order(metro_stations_points$NUMERO),]
```


Calculating distance between stations

```{r}
distance_stations <- st_distance(metro_stations_points,metro_stations_points)
```

Iterate to calculate distance from next station

```{r}

distance_list<- list()
origin_list <- list()
destination_list <- list()

for (i in 1:(nrow(distance_stations) - 1)) {
  
  temp_distances <- c()
  distance_ij <- distance_stations[i, i+1]
  temp_distances <- c(temp_distances, distance_ij)
  distance_list <- append(distance_list, temp_distances)
  
  temp_origin <- c()
  origin_i <- i
  temp_origin <- c(temp_origin,origin_i)
  origin_list<- append(origin_list,temp_origin)
  
  
  
  temp_destination <- c()
  destination_j <- i + 1
  temp_destination <- c(temp_destination,destination_j)
  destination_list <- append(destination_list,temp_destination)
  
  
}
```

Read as a data frame

```{r}
distance_stations_df <- data.frame(o_station = unlist(origin_list), d_station =  unlist(destination_list),distance = unlist(distance_list))
```

#### Setting trip speed

The duration of the trip between stations and the route scheduling is calculated considering the estimated mean travel speed, according to the local authorities.


Initial speed setting: 43 km/h according to [Metro de bogotá](https://www.metrodebogota.gov.co/?q=que-es-metro#:~:text=Conectar%C3%A1n%20el%20sur%20y%20el,de%20las%20obras%20del%20viaducto.) 

```{r}
speed_km_per_h <- 43 # speed in km/h
speed_m_per_m <- (speed_km_per_h*1000)/60 # speed in meters/minute
```

Calculate duration of trip between stations

```{r}
distance_stations_df <- distance_stations_df %>%
  mutate(dura_min = distance/speed_m_per_m)
```

#### Northbound trip

Stop time table for the northbound trip

```{r}
metro_stop_times_N <- metro_stops %>%
  mutate(trip_id = metro_trips$trip_id[2]) %>%
  relocate(trip_id)
```

Temporary list with zero in the final value

```{r}
temp_time_to_next_N <- list()
temp_time_to_next_N <- as.list(distance_stations_df$dura_min)
temp_time_to_next_N <- append(temp_time_to_next_N,0)
```

Append list in metro stops table

```{r}
metro_stop_times_N <- metro_stop_times_N %>%
  mutate(time_to_next = unlist(temp_time_to_next_N))
  
```

Creates the arrival and departure time columns

```{r}
metro_stop_times_N$arrival_time <- as_hms("08:00:00")
metro_stop_times_N$departure_time <- as_hms("08:00:00")

```

Iterate to calculate arrival and departure time according to time_to_next station

```{r}

for (i in 2:(nrow(metro_stop_times_N))) {
  
  metro_stop_times_N$arrival_time[i] = as_hms(metro_stop_times_N$departure_time[i-1] + hms(seconds = ceiling(metro_stop_times_N$time_to_next[i-1]*60)))
  
  metro_stop_times_N$departure_time[i] = metro_stop_times_N$arrival_time[i]
}


```

Creates the stop sequence field

```{r}

metro_stop_times_N$stop_sequence <- 0

for (i in 1:(nrow(metro_stop_times_N))) {
  metro_stop_times_N$stop_sequence[i] = i

}
```

Creates the timepoint field

```{r}
metro_stop_times_N$timepoint <- 0
```

Droping columns

```{r}
metro_stop_times_N <- metro_stop_times_N %>%
  dplyr::select(c(trip_id, arrival_time, departure_time, stop_id, stop_sequence, timepoint))
```


#### Southbound trip

Stop time table for the south direction trip

```{r}
metro_stop_times_S <- metro_stops %>%
  mutate(trip_id = metro_trips$trip_id[1]) %>%
  relocate(trip_id)
```

Inverse sorting

```{r}
metro_stop_times_S <- metro_stop_times_S[order(metro_stop_times_S$stop_code,decreasing = TRUE),]
```


Temporary list with zero in the final value

```{r}
temp_time_to_next_S <- list()
temp_time_to_next_S <- rev (as.list(distance_stations_df$dura_min)) #Inverse sorting
temp_time_to_next_S <- append(temp_time_to_next_S,0)
```

Append list in metro stops table

```{r}
metro_stop_times_S <- metro_stop_times_S %>%
  mutate(time_to_next = unlist(temp_time_to_next_S))
  
```

Creates the arrival and departure time columns

```{r}
metro_stop_times_S$arrival_time <- as_hms("04:00:00")
metro_stop_times_S$departure_time <- as_hms("04:00:00")

```

Iterate to calculate arrival and departure time according to time_to_next station

```{r}

for (i in 2:(nrow(metro_stop_times_S))) {
  
  metro_stop_times_S$arrival_time[i] = as_hms(metro_stop_times_S$departure_time[i-1] + hms(seconds = ceiling(metro_stop_times_S$time_to_next[i-1]*60)))
  
  metro_stop_times_S$departure_time[i] = metro_stop_times_S$arrival_time[i]
}


```

Creates the stop sequence field

```{r}

metro_stop_times_S$stop_sequence <- 0

for (i in 1:(nrow(metro_stop_times_S))) {
  metro_stop_times_S$stop_sequence[i] = i

}
```

Creates the timepoint field

```{r}
metro_stop_times_S$timepoint <- 0
```

Droping columns

```{r}
metro_stop_times_S <- metro_stop_times_S %>%
  dplyr::select(c(trip_id, arrival_time, departure_time, stop_id, stop_sequence, timepoint))
```

#### Appeding trips

Appends both northbound and southbound trips

```{r}
metro_stop_times_full <- bind_rows(metro_stop_times_N,metro_stop_times_S)
```


### Frequencies

Peak hours, off peak hours and periodicity

```{r}
start_time_list <- list("00:00:00","05:30:00", "09:00:00", "16:00:00", "19:00:00")
end_time_list <- list("05:29:59","08:59:59","15:59:59", "18:59:59","23:59:59")
periodicity_list <- list(15,3,15,3,15)
```

#### North direction trip

Creates frequencies initial data frame

```{r}
metro_frequencies_columns = c(names(brt_gtfs$frequencies)) 
metro_frequencies_N = data.frame(matrix(nrow = 5, ncol = length(metro_frequencies_columns))) 
colnames(metro_frequencies_N) = metro_frequencies_columns
```

Assign trip value, star and end time values

```{r}
metro_frequencies_N$trip_id <- metro_trips$trip_id[2]
metro_frequencies_N$start_time <- as_hms("00:00:00")
metro_frequencies_N$end_time <- as_hms("00:00:00")
```

Assign to dataframe

```{r}
metro_frequencies_N$start_time <- unlist(start_time_list)
metro_frequencies_N$end_time <- unlist(end_time_list)
metro_frequencies_N$periodicity <- unlist(periodicity_list)
```

Calculate headway_secs

```{r}
metro_frequencies_N$headway_secs <- metro_frequencies_N$periodicity*60
```

#### Southbound trip

Creates mirror frequency table for south direction trip

```{r}
metro_frequencies_S <- metro_frequencies_N
metro_frequencies_S$trip_id <- metro_trips$trip_id[1]
```

#### Appending trips

Appends both north and south direction trips

```{r}
metro_frequencies_full <- bind_rows(metro_frequencies_S,metro_frequencies_N)
```

Droping periodicity columns

```{r}
metro_frequencies_full <- metro_frequencies_full %>%
  dplyr::select(!c(periodicity))
```

Creating exact time column

```{r}
metro_frequencies_full$exact_times <- 0
```


### Fare attributes

Non existing optional table, not considered an obstacle for the accessibility modelling.

### Fare rules 

Non existing optional table, not considered an obstacle for the accessibility modelling.

### Compilation

Every GTFS table created is compiled into zip file.

#### Write

List of origin and destination files

```{r}
items <- list(
  metro_agency = "agency.txt",
  metro_routes = "routes.txt",
  metro_trips = "trips.txt",
  metro_stops = "stops.txt",
  metro_calendar = "calendar.txt",
  metro_calendar_dates = "calendar_dates.txt",
  metro_shapes = "shapes.txt",
  metro_stop_times_full = "stop_times.txt",
  metro_frequencies_full = "frequencies.txt"
)
```

Input directory

```{r}
input_directory <- "Data/Preprocessed/Metro/GTFS/Inputs/"
```


Writes dataframes as txt files

```{r}

for (i in names(items)) {
  file_path <- paste0(input_directory, items[[i]])
  write.table(get(i), file_path, sep=",", quote=FALSE, row.names = FALSE)
}
```



#### Store


Creates zipfile

```{r}
zip(zipfile = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", files = list.files("Data/Preprocessed/Metro/GTFS/Inputs/", full.names = TRUE),mode = "cherry-pick")

```


#### Read

Reads resulting Metro GTFS Data

```{r}
metro_gtfs <- read_gtfs("Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip")

names(metro_gtfs)
```

## Data inspection

### Summary

```{r}
summary(metro_gtfs)
```

### Profiling

```{r}
plot_str(metro_gtfs)
```

### Validation

```{r}
validate_gtfs(
  "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip",
  output_path = "Data/Preprocessed/Metro/GTFS/Validation/",
  validator_path = download_validator(tempdir())
)
```

### Review

#### Agency

```{r}
head(metro_gtfs$agency)
```
```{r}
Datatypelist_metro_agency <- metro_gtfs$agency %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_metro_agency
```




#### Routes

```{r}
head(metro_gtfs$routes)
```

#### Trips

```{r}
metro_gtfs$trips
```

#### Stops

Reads stop_lat and stop_lon as numeric

```{r}
metro_gtfs$stops$stop_lat = as.numeric(as.character(metro_gtfs$stops$stop_lat))
metro_gtfs$stops$stop_lon = as.numeric(as.character(metro_gtfs$stops$stop_lon))
```

Dataframe

```{r}
metro_gtfs$stops
```

#### Calendar

```{r}
metro_gtfs$calendar
```
Data type

```{r}
Datatypelist_metro_calendar <- metro_gtfs$calendar %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")
Datatypelist_metro_calendar
```


#### Calendar dates

```{r}
metro_gtfs$calendar_dates
```

#### Shapes

Reads as numeric

```{r}
metro_gtfs$shapes$shape_dist_traveled = as.numeric(as.character(metro_gtfs$shapes$shape_dist_traveled))
metro_gtfs$shapes$Shape_Leng = as.numeric(as.character(metro_gtfs$shapes$Shape_Leng))
```

Dataframe

```{r}
metro_gtfs$shapes
```

Geometry

```{r}
geo_metro_shapes <- gtfstools::get_trip_geometry(metro_gtfs, file = "shapes")
```

Quick temathic map

```{r}
qtm(geo_metro_shapes)
```

##### Saving

```{r}
geo_metro_shapes %>%
  st_write("Data/Preprocessed/Metro/Network/Metro_Network.gpkg",
           "Main",
           delete_layer=TRUE)
```



#### Stop times

Stop time data frame

```{r}
metro_gtfs$stop_times
```

#### Frequencies

Frequencies data frame

```{r}
metro_gtfs$frequencies
```

#### Detail review

##### Testing track and stations and track overlap in metro case

Geometry of track

```{r}
geo_metro_shapes <- gtfstools::get_trip_geometry(metro_gtfs, file = "shapes")
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_shapes) +
  theme_minimal()
```


Geometry of stations

```{r}
geo_metro_stations <- convert_stops_to_sf(metro_gtfs, stop_id = NULL, crs = 4326)
```

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_stations) +
  theme_minimal()
```

Overlap of station point

Plotting

```{r}
ggplot() +
  geom_sf(data = geo_metro_stations) +
  geom_sf(data = geo_metro_shapes) + 
  theme_minimal()
```

Intesect

```{r}
inter_metro_stops_shape <- st_intersection(geo_metro_stations,geo_metro_shapes)
```
Review

```{r}
inter_metro_stops_shape
```

# Multipurpose survey

In order to assess the accessibility results using socioeconomic variables (income decile), the data gathered in the Multipurpose Survey [Encuesta Multiproposito] is used. The survey data is divided into two sets of data: the main forms and the additional variables (which includes a houshold income estimation).

## Reading the data

### ZPU layer

At the geographical-administrative level, Bogota is geographicaly divided in Zonal Planning Units - ZPU [Unidades de planeación Zonal - UPZ]. The Multipurpose Survey stores this ZPU int the data gathering process so, in order to geographically relate results with socioeconomic variables, this ZPU are use as spatial aggregations units.


```{r}
geo_zpu <- st_read("Data/Raw/Demo/Survey/Shape/ShapeEM2021/EM2021_UPZ.shp")
```

Geometry

```{r}
qtm(geo_zpu)
```

### Survey data

#### Main forms

Downloading and reading from source

```{r}
# url<- "https://www.sdp.gov.co/sites/default/files/encuestas-multiproposito/20230620em2021.zip"
# 
# download.file(url,"Data/Survey/CSV_Main/20230620em2021.zip")
# 
# unzip("Data/Survey/CSV_Main/20230620em2021.zip",exdir = "Data/Survey/CSV_Main")
# 
# survey_raw <- read_csv("Data/Survey/CSV_Main/20230620EM2021.csv")
```

Reading from local

```{r}
survey_raw <- read_csv("Data/Raw/Demo/Survey/CSV_Main/20230620EM2021.csv")
```

Preview

```{r}
head(survey_raw,10)
```

#### Additional variables

Downloading and reading from source

```{r}
# url<- "https://www.sdp.gov.co/sites/default/files/encuestas-multiproposito/20230220_variables_adicionales_em2021_csv.zip"
# 
# download.file(url,"Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021_csv.zip")
# 
# unzip("Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021_csv.zip",exdir = "Data/Survey/CSV_Additional")
# 
# survey_add_raw <- read_csv("Data/Survey/CSV_Additional/20230220_variables_adicionales_em2021.csv")
```

Reading from local

```{r}
survey_add_raw <- read_csv("Data/Raw/Demo/Survey/CSV_Additional/20230220_variables_adicionales_em2021.csv")
```

Preview

```{r}
head(survey_add_raw,10)
```

## Data inspection

### ZPU layer

CRS

```{r}
st_crs(geo_zpu)
```
New CRS

```{r}
geo_zpu_wgs84 <- geo_zpu %>%
  st_transform(.,4326)
```

Map

```{r}
qtm(geo_zpu_wgs84)
```


Review new CRS

```{r}
st_crs(geo_zpu_wgs84)
```

Summary

```{r}
summary(geo_zpu)
```

UPZEM: Numeric UPZEM2: String

### Survey data

#### Main forms

Data type

```{r}
Datatypelist_survey <- survey_raw %>% 
  summarise_all(class) %>%
  pivot_longer(everything(), 
               names_to="All_variables", 
               values_to="Variable_class")

Datatypelist_survey
```

##### Profiling

Summary

```{r}
#introduce(survey_raw)
```

Missing values

```{r}
plot_missing(survey_raw)
```

Missing values on ID fields

```{r}
survey_raw_id <- survey_raw %>% 
  dplyr::select(directorio, directorio_per, dpto, mpio, clase, cod_localidad, nombre_localidad, cod_upz_grupo, nombre_upz_grupo, estrato2021, nombre_estrato, fex_c)

plot_missing(survey_raw_id)

```

Missing values by ZPU

```{r}
na_by_zpu <- survey_raw %>%
  group_by(cod_upz_grupo) %>%
  summarize(count_entry = n()) %>%
  mutate(percentage_entry = count_entry / nrow(survey_raw) * 100) %>%
  arrange(desc(percentage_entry))

head(na_by_zpu)
```

Missing ZPU by "directorio"

```{r}
# entry_by_directorio <- survey_raw %>%
#   group_by(directorio) %>%
#   summarize(count_entry = n(),count_na = sum(is.na(cod_upz_grupo))) %>%
#   mutate(percentage_entry = count_entry / nrow(survey_raw) * 100) %>%
#   mutate(control = ifelse(count_entry == count_na,"All na's", "None")) %>%
#   mutate(diff = count_entry - count_na) %>%
#   arrange((diff))
# 
# entry_by_directorio
```

Filter equal values

```{r}
# entry_by_directorio_control <- filter(entry_by_directorio, control == "None") %>%
#   mutate(control_diff = diff==count_entry)
# 
# unique(entry_by_directorio_control$control_diff)
```

All entries, either have all NA's value per "directorio" or none.

Missing ZPU

```{r}
filter(survey_raw, is.na(cod_upz_grupo))

```

##### Example

In order to better comprehend the survey structure, a specific survey is reviewed in detail.

directorio = "220102"

```{r}
# filter(survey_raw, directorio == "220102") %>%
#   dplyr::select(directorio,directorio_per, directorio_hog, # ID
#          cod_upz_grupo, # ZPU code
#          nombre_upz_grupo, # ZPU name
#          orden, # Order in home
#          npcep4, # Age
#          npcep6, # Relation to Household leader
#          npcep11a) # Place of birth
```

#### Additional variables

Data type

```{r}
# Datatypelist_survey_add <- survey_add_raw %>% 
#   summarise_all(class) %>%
#   pivot_longer(everything(), 
#                names_to="All_variables", 
#                values_to="Variable_class")
# 
# Datatypelist_survey_add
```

##### Profiling

Summary

```{r}
#introduce(survey_add_raw)
```

Missing values

```{r}
#plot_missing(survey_raw)
```

Missing values on ID fields

```{r}
# survey_add_raw %>% dplyr::select(directorio, directorio_hog,directorio_per) %>%
#   plot_missing(.)

```

##### Aggregation process

Initial number of rows

```{r}
nrow(survey_add_raw)
```

Erasing duplicates of location id for later merge

```{r}
survey_raw_unique <- survey_raw %>%
  dplyr::select(directorio,cod_upz_grupo,nombre_upz_grupo) %>%
  distinct(.) %>%
  na.omit(.)
```

Merge with UPZ id variables from main form survey

```{r}
survey_add <- left_join(
  survey_add_raw,# Additional variables df
  survey_raw_unique, # filtered main form df
  by = "directorio"
  ) %>%
  relocate(directorio) %>%
  relocate(cod_upz_grupo, .after = directorio_per) %>%
  relocate(nombre_upz_grupo, .after = cod_upz_grupo)
```

Review

Number of rows

```{r}
nrow(survey_add)
```

General review

```{r}
head(survey_add)
```

Example review

```{r}
# filter(survey_raw, directorio == "220102") %>%
#   dplyr::select(
#     directorio,directorio_hog,directorio_per, # ID
#     cod_upz_grupo,
#     nombre_upz_grupo)
```

Droping rows with no UPZ code and name

```{r}
columns_to_omit <- c("cod_upz_grupo", "nombre_upz_grupo")
survey_add_clean <- survey_add[complete.cases(survey_add[, columns_to_omit]),]
```

Droping review

```{r}
# head(survey_add_clean)
```
Number of rows in cleaned add survey data

```{r}
# nrow(survey_add_clean)
```

##### Homes

Home incomde mean and medean are calculated.

```{r}
survey_add_homes <- survey_add_clean %>%
  group_by(cod_upz_grupo, directorio_hog) %>%
  summarize(count_income = n(),income_mean = mean(N_INGTOT_PER,na.rm = TRUE), income_median = median(N_INGTOT_PER,na.rm = TRUE))
  
```

Review

```{r}
# survey_add_homes
```


##### ZPU

ZPU income mean and income median are calculated based on the home mean and median income. 

```{r}
survey_add_zpu <- survey_add_homes %>%
  group_by(cod_upz_grupo) %>%
  summarize(count_homes = n(),income_mean_mean_zpu = mean(income_mean,na.rm = TRUE), income_median_median_zpu = median(income_median,na.rm = TRUE), income_median_mean_zpu = mean(income_median,na.rm = TRUE), income_mean_median_zpu = median(income_mean,na.rm = TRUE))
```

###### Plotting

Left join with ZPU layer

```{r}
geo_zpu_survey_add <- geo_zpu_wgs84 %>%
  left_join(survey_add_zpu, by = c("UPZEM" = "cod_upz_grupo"))
```

Plot

Mean mean

```{r}
ggplot(geo_zpu_survey_add) +
  geom_sf(aes(fill = income_mean_mean_zpu), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Mean household income\nColombian Pesos") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Demo_Income_UPZ_Mean_Mean.png", path = "Data/Results/Images/")
```

Median mean

```{r}
ggplot(geo_zpu_survey_add) +
  geom_sf(aes(fill = income_median_mean_zpu), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Median mean household income\nColombian Pesos") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Demo_Income_UPZ_Median_Mean.png", path = "Data/Results/Images/")
```

Median median

```{r}
ggplot(geo_zpu_survey_add) +
  geom_sf(aes(fill = income_median_median_zpu), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Median household income\nColombian Pesos") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Demo_Income_UPZ_Median_Median.png", path = "Data/Results/Images/")
```

Mean median

```{r}
ggplot(geo_zpu_survey_add) +
  geom_sf(aes(fill = income_mean_median_zpu), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Median household income\nColombian Pesos") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Demo_Income_UPZ_Mean_Median.png", path = "Data/Results/Images/")
```


##### Example

directorio = "220102"

```{r}
# survey_add_raw_E1<- filter(survey_add, directorio == "220102") %>%
#   dplyr::select(
#     directorio,directorio_hog,directorio_per, # ID
#     N_fuerza_trabajo, # In labour market
#     N_informal, # Informal
#     N_analfabeta, # Illiterate
#     N_pobre_ipm, # MPI poor
#     N_codigo_upz_trabajo, # ZPU ID of workplace
#     N_INGTOT_PER, # Total income 
#     N_pobre_monetario,# Monetary poverty
#     cod_upz_grupo,
#     nombre_upz_grupo) 
```

Review

```{r}
# survey_add_raw_E1
```



Testing descriptive statistics

```{r}
# mean(survey_add_raw_E1$N_INGTOT_PER,na.rm = TRUE)
```


# Land use

To locate the main clusters of economic activity (job opportunities), spatial data of the main use of the real state properey terrain is used.

## Data reading

```{r}
land_use_terrain <- st_read("Data/Raw/Land_use/Terrain/DestinoSHP/Destino.shp")
```
Geometry

```{r}
#qtm(land_use_terrain)
```

Invalid poligons

## Data inspection

CRS

```{r}
st_crs(land_use_terrain)
```

Set the polygon object in WGS84 CRS

```{r}
land_use_terrain84 <- land_use_terrain %>%
  st_set_crs(.,4326)
```

New CRS


```{r}
st_crs(land_use_terrain84)
```

## Data cleaning

Invalid geometries

```{r}
invalid_geo_land_use <- st_is_valid(land_use_terrain84, reason = TRUE)
```

Clean geometry

```{r}
land_use_terrain84_clean <- st_make_valid(land_use_terrain84)
```


Map

```{r}
qtm(land_use_terrain84_clean)
```



# Preprocessing

## Spatial analysis unit

H3 hexagonal grid

Dissolve polygons

```{r}
geo_zpu_wgs84_mono <- st_union(geo_zpu_wgs84, by_feature = FALSE)
```

### Hegagonal grid

#### Resolution 9

Intersecting grids

```{r}
intergrid_9 <- polyfill(geo_zpu_wgs84_mono, res = 9)
```
H3 id to sf

```{r}
hex_grid_9<- h3_to_geo_boundary_sf(intergrid_9)
```

Basic geo map

```{r}
ggplot() +
  geom_sf(data = hex_grid_9) +
  theme_minimal()
```



## Data enrichment


### Survey

#### Main forms

#### Additional variables

##### Spatial join

Join

```{r}
survey_add_intersect_hex9 <- st_intersection(hex_grid_9,geo_zpu_survey_add)
```

Intersecting area between objects

```{r}
intersect_areas <- st_area(survey_add_intersect_hex9)
```

Storing the intersecting area

```{r}
survey_add_intersect_hex9$intersect_area <- as.numeric(st_area(survey_add_intersect_hex9))
```

Weighted income mean: As the geometry of the H3 hexagons differs from the ZPU geometry, the income result for every hexagon will be result of an area weighted average of the overlapped ZPU income values.

```{r}
survey_add_intersect_hex9 <- survey_add_intersect_hex9 %>%
  mutate(weighted_income = income_mean_mean_zpu * intersect_area) %>%
  group_by(h3_index) %>%
  summarize(area_weighted_income_mean = sum(weighted_income) / sum(intersect_area)) %>%
  st_drop_geometry(.)
```

Decile label

```{r}
survey_add_intersect_hex9$income_decile <- ntile(survey_add_intersect_hex9$area_weighted_income_mean, 10)
```

Quartile label

```{r}
survey_add_intersect_hex9$income_quartile <- ntile(survey_add_intersect_hex9$area_weighted_income_mean, 4)
```


Detail review

```{r}
filter(survey_add_intersect_hex9, h3_index == "8966e090e1bffff")
```



### Land use

Spatial join between hexagon grid and land use layer

```{r}
# hex9_land_use_join <- st_join(hex_grid_9, land_use_terrain84_clean, join = st_intersects )
```



Pivot wide by land use category

```{r}
# hex9_land_use_join_wide <- hex9_land_use_join %>%
# 
#   group_by(h3_index, DESTINOCOD) %>%
#   summarize(count_land_use_code = n())  %>%
#   pivot_wider(names_from = "DESTINOCOD", values_from = "count_land_use_code", values_fill = 0 , names_prefix = "LU_COD_")
# 
# 
#   
```
Review

```{r}
# head(hex9_land_use_join_wide)
```
Dropping geometry column

```{r}
# hex9_land_use_join_wide <- hex9_land_use_join_wide %>%
#   dplyr::select(!geometry) %>%
#   st_drop_geometry(.)
```


Review

```{r}
# head(hex9_land_use_join_wide)
```

Merge with initial hexagon grid

```{r}
# hex9_land_use_final <- merge(hex_grid_9, hex9_land_use_join_wide, by.x = "h3_index", by.y = "h3_index", all.x = TRUE)

```

Saving hexagon grid

```{r}
# hex9_land_use_final %>%
#   st_write("Data/Preprocessed/Grid/Hex9_grid.gpkg",
#            "Hex9_LU",
#            delete_layer=TRUE)
```

Reading from preprocessed directory

```{r}
hex9_land_use_final <- st_read("Data/Preprocessed/Grid/Hex9_grid.gpkg","Hex9_LU")
```


Review

```{r}
head(hex9_land_use_final)
```

Plotting

```{r}
ggplot(hex9_land_use_final) +
 # ggtitle("Opportunities") + 
  geom_sf(aes(fill = LU_COD_21), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Commercial corridor\nOpportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Opportunities_COD_21.png", path = "Data/Results/Images/")
```


## Origin and destination points

```{r}
hex9_points <- hex9_land_use_final %>%
  st_centroid() %>%
  rename(id = h3_index)
  
```

Geometry

```{r}
qtm(hex9_points)
```

Calculate lon and lat coordinates

```{r}
hex9_points$lon <- st_coordinates(hex9_points)[, 1]
hex9_points$lat <- st_coordinates(hex9_points)[, 2]
```

Drop geometry of hex grid

```{r}
hex9_points <- hex9_points %>% 
  st_drop_geometry() %>%
  relocate(lon, .after = id) %>%
  relocate(lat, .after = lon)
```

Save point data as csv

```{r}
# write.csv(hex9_points,file='Data/Preprocessed/Grid/Hex9_grid_LU.csv', row.names=FALSE)
```

# Pre modelling tables

## Transport infrastructure

### Metro

#### Agency

```{r}
# xtable(metro_agency)
```
#### Routes

```{r}
# xtable(metro_routes)
```
#### Trips

```{r}
# xtable(metro_trips)
```

#### Calendar

```{r}
# xtable(metro_calendar)
```


#### Calendar dates

```{r}
# xtable(head(metro_calendar_dates))
```
#### Shapes


```{r}
# metro_shapes_table <- metro_shapes
# 
# 
# metro_shapes_table$shape_pt_lon <- format(metro_shapes_table$shape_pt_lon, nsmall = 4)
# metro_shapes_table$shape_pt_lat<- format(metro_shapes_table$shape_pt_lat, nsmall = 4)
# 
# 
# xtable_obj <- xtable(head(metro_shapes_table))
# 
# 
# print(xtable_obj)
```
#### Stops

```{r}
# metro_stops_table <- metro_stops
# 
# 
# metro_stops_table$stop_lon <- format(metro_stops_table$stop_lon, nsmall = 4)
# metro_stops_table$stop_lat<- format(metro_stops_table$stop_lat, nsmall = 4)
# 
# 
# xtable_obj <- xtable(head(metro_stops_table))
# 
# 
# print(xtable_obj)
```

#### Stop times



```{r}
# metro_stop_times_full_table <- metro_stop_times_full 
# 
# 
# metro_stop_times_full_table$arrival_time <- as.character(metro_stop_times_full_table$arrival_time)
# 
# metro_stop_times_full_table$departure_time <- as.character(metro_stop_times_full_table$departure_time)
# 
# metro_stop_times_full_table$stop_sequence <- as.integer(metro_stop_times_full_table$stop_sequence)
# 
# metro_stop_times_full_table$timepoint <- as.integer(metro_stop_times_full_table$timepoint)
# 
# xtable(head(metro_stop_times_full_table,5))
```
#### Frequencies

```{r}
# metro_frequencies_full_table <- metro_frequencies_full 
# 
# 
# metro_frequencies_full_table$start_time <- as.character(metro_frequencies_full_table$start_time)
# 
# metro_frequencies_full_table$end_time <- as.character(metro_frequencies_full_table$end_time)
# 
# metro_frequencies_full_table$exact_times <- as.integer(metro_frequencies_full_table$exact_times)
# 
# metro_frequencies_full_table$headway_secs <- as.integer(metro_frequencies_full_table$headway_secs)
# 
# 
# xtable(head(metro_frequencies_full_table,5))
```



# Pre modelling plotting

In the following section, every input of the modelling process is plotted individually.

## Transport infrastructure

### Metro

Fill in polygon


```{r}
geo_zpu_wgs84_mono_fill <- st_make_valid(geo_zpu_wgs84_mono)
```


Plotting

```{r}
legend_data <- data.frame(
  label = c("Metro Lines", "Metro Stations"),
  color = c("#5ab4ac", "#d8b365")
)

ggplot() +
  geom_sf(data = geo_zpu_wgs84_mono_fill) + 
  geom_sf(data = raw_metro_line, aes(color = "Metro Lines"), lwd = 1.1) +
  geom_sf(data = raw_metro_stations, aes(color = "Metro Stations"), lwd=1.6) +
 theme_minimal() +
  scale_color_manual(values = legend_data$color, labels = legend_data$label) + labs(color=NULL) + annotation_scale(location = "br", width_hint = 0.1) +
  annotation_north_arrow(location = "tl", which_north = "true", 
        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
        style = north_arrow_fancy_orienteering,scale = 0.1,height = unit(1, "cm"),
  width = unit(1, "cm"))

ggsave("Metro_Network.png", path = "Data/Results/Images/")
```

### Land use


```{r}
ggplot() +
  geom_sf(data = land_use_terrain84, aes(fill = factor(DESTINOCOD == "21")), color = NA) +
  scale_fill_manual(values = c("TRUE" = "#43a2ca", "FALSE" = "#e0f3db")) +
  labs(color = NULL) +
  theme_minimal() +
  guides(fill = "none") + annotation_scale(location = "br", width_hint = 0.1) +
  annotation_north_arrow(location = "tl", which_north = "true", 
        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
        style = north_arrow_fancy_orienteering,scale = 0.1,height = unit(1, "cm"),
  width = unit(1, "cm"))

ggsave("Land_Use_Commercial_Corridor_Terrain.png", path = "Data/Results/Images/")
```

### Area of study

#### ZPU

```{r}
ggplot() +
  geom_sf(data = geo_zpu_wgs84) + annotation_scale(location = "br", width_hint = 0.1) +
  annotation_north_arrow(location = "tl", which_north = "true", 
        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
        style = north_arrow_fancy_orienteering,scale = 0.1,height = unit(1, "cm"),
  width = unit(1, "cm")) + 
  theme_minimal()

ggsave("Study_Area_UPZ.png", path = "Data/Results/Images/")

```


# Accessiblity modelling

The next section of the code aims to calculate the accessibility measure across different transport scenarios and transportation modes. The modeled transportation modes considered in the accessibility measure are:
- Walking only mode
- Base (before) scenario: BRT + walking mode
- Metro only scenario
- Future (after) scenario: BRT + metro + walking mode

For every scenario or mode, two accessibility modelling libraries are used for control and comparison purposes:
- Accessibility package
- R5R package


## Data preparation

Creates directory for accessibility analysis

```{r}
access_dir <- "Accessibility"
dir.create(access_dir)
```

Creates before and after directories

```{r}
before_dir <- file.path(access_dir, "Before")
metro_dir <- file.path(access_dir, "Metro")
after_dir <- file.path(access_dir, "After")

dir.create(before_dir)
dir.create(metro_dir)
dir.create(after_dir)

```

Copy input files to before directory

Before data

```{r}
# BRT GTFS data
file.copy(from = "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip", to = file.path(before_dir, "brt_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(before_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(before_dir, "hex9_points_LU.csv"))

```

Metro data

```{r}

# Metro GTFS data
file.copy(from = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", to = file.path(metro_dir, "metro_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(metro_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(metro_dir, "hex9_points_LU.csv"))


```

After data

```{r}

# BRT GTFS data
file.copy(from = "Data/Raw/Transport/BRT/GTFS-2023-06-21.zip", to = file.path(after_dir, "brt_gtfs.zip"))

# Metro GTFS data
file.copy(from = "Data/Preprocessed/Metro/GTFS/Final/Metro-GTFS.zip", to = file.path(after_dir, "metro_gtfs.zip"))

# OSM Street network
file.copy(from = "Data/Raw/Transport/OSM/Bogota_general_network.osm.pbf", to = file.path(after_dir, "street_network.osm.pbf"))

# Hexagon opportunities data based on hexagon grid
file.copy(from = "Data/Preprocessed/Grid/Hex9_grid_LU.csv", to = file.path(after_dir, "hex9_points_LU.csv"))
```


Visualize directory

```{r}
fs::dir_tree(access_dir)
```
## Parameters

Parameters value in accessibility modelling

```{r}
# Time travel parameters
ttm_global_cutoff <- 60 # minutes
ttm_max_walk_time <- 30 # minutes
ttm_max_trip_duration <- 60 # minutes


# R5R parameters
r5r_global_cutoff <- 60 # minutes
r5r_max_walk_time <- 30 # minutes
r5r_max_trip_duration <- 60 # minutes
```

## Walking mode

Considers just walking mode.

### Setup

```{r}
r5r_walk <- setup_r5("Accessibility/Before", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Before/hex9_points_LU.csv")
```


### Time travel matrix


```{r}
ttm_walk <- travel_time_matrix(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_walk, "travel_time_p50", "travel_time")
```

Creates a time matrix object

```{r}
main_ttm_hex9 <- rename(ttm_walk, walk_tt = travel_time)
```

### Accessibility package

#### Cumulative opportunities measure

Commercial corridor opportunities

```{r}
cum_opportunities_walk <- cumulative_cutoff(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_walk)
```

#### Minimum travel cost

Commercial corridor opportunities

```{r}
min_time_walk <- cost_to_closest(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_walk)
```

### R5R package

```{r}
r5r_access_walk <- accessibility(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_walk)
```
### Results comparison

Using accessibility package

```{r}
cum_cutoff_walk <- cumulative_cutoff(
  ttm_walk,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_walk <- merge(
  r5r_access_walk,
  cum_cutoff_walk,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_walk,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_walk[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution

Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  hex_grid_9,
  r5r_access_walk,
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_walk_30 = accessibility)
```

Drop cutoff and percentile column

```{r}
main_results_hex9 <- main_results_hex9 %>%
  dplyr::select(!c(cutoff,percentile))
```
Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_brt) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```


Regular Vidiris color scheme

```{r}
# plot_title <- paste("Walking accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  # ggtitle(plot_title) +
  geom_sf(aes(fill = b_walk_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Walking\nAccessible\nOpportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold")) ++ annotation_scale(location = "br", width_hint = 0.1) +
  annotation_north_arrow(location = "tl", which_north = "true", 
        pad_x = unit(0.1, "in"), pad_y = unit(0.1, "in"),
        style = north_arrow_fancy_orienteering,scale = 0.1,height = unit(1, "cm"),
  width = unit(1, "cm"))

ggsave("Access_Walk_base.png", path = "Data/Results/Images/")
```

## Base scenario: BRT + walking

It does not have the future metro data.

### Setup

```{r}
r5r_before <- setup_r5("Accessibility/Before", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Before/hex9_points_LU.csv")
```

### Time travel matrix

Without erasing geometries

```{r}
ttm_brt <- travel_time_matrix(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_brt, "travel_time_p50", "travel_time")
```

Merging

```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_brt,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, brt_tt = travel_time)
```


### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_brt <- cumulative_cutoff(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_brt)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_brt <- cost_to_closest(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_brt)
```

### R5R package

```{r}
r5r_access_brt <- accessibility(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK","BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_brt)
```

### Results comparison

Using accessibility package

```{r}
cum_cutoff_brt <- cumulative_cutoff(
  ttm_brt,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_brt <- merge(
  r5r_access_brt,
  cum_cutoff_brt,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_brt,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_brt[, .(id, r5r_access, accessibility_access)])
```

Results consistent across methods.

### Spatial distribution


Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_brt[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_brt_30 = accessibility)
```

Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_brt) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```


Regular Vidiris color scheme

```{r}

# plot_title <- paste("BRT accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = b_brt_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Walking and BRT\nAccessible\nOpportunities") +
  #theme_minimal() + 
    theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_BRT_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not ar use)

```{r}
# main_results_hex9 %>%
#   st_write("Data/Results/Before/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_brt",
#            delete_layer=TRUE)
```



## Metro only scenario

### Setup

```{r}
r5r_metro <- setup_r5("Accessibility/Metro", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/Metro/hex9_points_LU.csv")
```

### Inputs review




### Time travel matrix

Without erasing geometries

```{r}
ttm_metro <- travel_time_matrix(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "SUBWAY"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_metro, "travel_time_p50", "travel_time")
```


Merge

```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_metro,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, metro_tt = travel_time)
```


### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_metro <- cumulative_cutoff(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_metro)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_metro <- cost_to_closest(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_metro)
```

### R5R package

```{r}
r5r_access_metro <- accessibility(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK", "SUBWAY"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_metro)
```

### Results comparison

Using accessibility package

```{r}
cum_cutoff_metro <- cumulative_cutoff(
  ttm_metro,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_metro <- merge(
  r5r_access_metro,
  cum_cutoff_metro,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_metro,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_metro[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_metro[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, m_metro_30 = accessibility)
```


Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_metro) +
#   ggtitle("Metro accessibility: cutoffs = 30  max_walk_time = 30, max_trip_duration = 120") +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   #theme_minimal()
#   theme(plot.title = element_text(size = 8, face = "bold"))
# 
# ggsave("Metro.png", path = "Data/Results/Images/")
```


Regular Vidiris color scheme

```{r}

# plot_title <- paste("Metro accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)


ggplot(main_results_hex9) +
  # ggtitle(plot_title) +
  geom_sf(aes(fill = m_metro_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Walking and metro\nAccessible\nOpportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_Metro_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not in use, write just at the end)

```{r}
# spatial_r5r_metro %>%
#   st_write("Data/Results/Metro/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_metro",
#            delete_layer=TRUE)
```

## Future scenario: BRT and metro scenario

### Setup

```{r}
r5r_after <- setup_r5("Accessibility/After", verbose = FALSE)
```

Centroids of hexagons

```{r}
hex_points_main <- data.table::fread("Accessibility/After/hex9_points_LU.csv")
```

### Time travel matrix

Without erasing geometries

```{r}
ttm_full <- travel_time_matrix(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = ttm_max_walk_time,
  max_trip_duration = ttm_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Rename columns of time travel output

```{r}
data.table::setnames(ttm_full, "travel_time_p50", "travel_time")
```

Merging ttm results


```{r}
main_ttm_hex9 <- merge(
  main_ttm_hex9,
  ttm_full,
  by = c("from_id","to_id"),
)
```

Rename column

```{r}
main_ttm_hex9 <- rename(main_ttm_hex9, brt_metro_tt = travel_time)
```



### Accessibility package

#### Cumulative opportunities measure

High street retail opportunities

```{r}
cum_opportunities_full <- cumulative_cutoff(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff
)
```


Review

```{r}
head(cum_opportunities_full)
```

#### Minimum travel cost

To high street retail opportunities

```{r}
min_time_full <- cost_to_closest(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time"
)
```

Review

```{r}
head(min_time_full)
```

### R5R package

```{r}
r5r_access_full <- accessibility(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_global_cutoff,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_max_walk_time,
  max_trip_duration = r5r_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

Review

```{r}
head(r5r_access_full)
```
### Results comparison

Using accessibility package

```{r}
cum_cutoff_full <- cumulative_cutoff(
  ttm_full,
  land_use_data = hex_points_main,
  opportunity = "LU_COD_21",
  travel_cost = "travel_time",
  cutoff = ttm_global_cutoff-1
)
```

Merge results

```{r}
access_comparison_full <- merge(
  r5r_access_full,
  cum_cutoff_full,
  by = "id"
)
```


Setting columns names accross methods

```{r}
data.table::setnames(
  access_comparison_full,
  old = c("accessibility", "LU_COD_21"),
  new = c("r5r_access", "accessibility_access")
)
```

Review

```{r}
head(access_comparison_full[, .(id, r5r_access, accessibility_access)])
```

### Spatial distribution

Merging accessibility results with hexagon grid

```{r}
# spatial_r5r_full <- merge(
#   hex_grid_9,
#   r5r_access_full,
#   by.x = "h3_index",
#   by.y = "id"
# )
```

Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_full[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, a_brt_metro_30 = accessibility)
```


Plotting

Inferno Viridis color scheme

```{r}
# ggplot(spatial_access_full) +
#   geom_sf(aes(fill = LU_COD_21), color = NA) +
#   scale_fill_viridis_c(option = "inferno") +
#   labs(fill = "Accessible\nHigh Street Retail") +
#   theme_minimal()
```

Regular Vidiris color scheme

```{r}
# plot_title <- paste("BRT and Metro accessibility: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)



ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = a_brt_metro_30), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Walking, BRT and metro\nAccessible\nOpportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_BRT_Metro_base.png", path = "Data/Results/Images/")
```

Save results in geopackage (not in use, save at the end)

```{r}
# spatial_r5r_full %>%
#   st_write("Data/Results/After/Grid/Hex9_grid.gpkg",
#            "Hex9_spatial_r5r_full",
#            delete_layer=TRUE)
```

## Time travel matrix

Time travel matrix review

Head

```{r}
head(main_ttm_hex9)
```

Summary

```{r}
summary(main_ttm_hex9)
```
### Variations

```{r}
main_ttm_hex9 <- main_ttm_hex9 %>%
  mutate(
    diff_walk_metro = metro_tt - walk_tt,
    diff_walk_brt = brt_tt - walk_tt,
     diff_walk_brt_metro = brt_metro_tt - walk_tt,
    diff_brt_brt_metro = brt_metro_tt - brt_tt)
```

Summary after variations

```{r}
summary(main_ttm_hex9)
```
Groping results by origin hexagon

```{r}
sta_diff_ttm_hex9 <- main_ttm_hex9 %>%
  group_by(from_id) %>%
  summarise(across(contains("diff"), list(
    Min = min,
    Max = max,
    Mean = mean,
    Median = median,
    SD = sd
  )))
```

Merging statistic results with hexagon matrix

```{r}
geo_sta_diff_ttm_hex9 <- merge(
  hex_grid_9,
  sta_diff_ttm_hex9,
  by.x = "h3_index",
  by.y = "from_id"
)
```

#### Plotting

##### Walking vs BRT

Mean

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs BRT") + 
  geom_sf(aes(fill = diff_walk_brt_Mean), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Mean commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_BRT_Mean.png", path = "Data/Results/Images/")
```
Median

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs BRT") + 
  geom_sf(aes(fill = diff_walk_brt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_BRT_Median.png", path = "Data/Results/Images/")
```
Minimum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs BRT") + 
  geom_sf(aes(fill = diff_walk_brt_Min), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Minimum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_BRT_Min.png", path = "Data/Results/Images/")
```
Maximum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs BRT") + 
  geom_sf(aes(fill = diff_walk_brt_Max), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Maximum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_BRT_Max.png", path = "Data/Results/Images/")
```



##### Walking vs Metro

Mean

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs Metro") + 
  geom_sf(aes(fill = diff_walk_metro_Mean), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Mean commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_Metro_Mean.png", path = "Data/Results/Images/")
```
Median

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs Metro") + 
  geom_sf(aes(fill = diff_walk_metro_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_Metro_Median.png", path = "Data/Results/Images/")
```

Minimum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs Metro") + 
  geom_sf(aes(fill = diff_walk_metro_Min), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Minimum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_Metro_Min.png", path = "Data/Results/Images/")
```
Maximum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: Walking vs Metro") + 
  geom_sf(aes(fill = diff_walk_metro_Max), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Maximum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_Walk_Metro_Max.png", path = "Data/Results/Images/")
```


##### BRT vs BRT + Metro

Mean

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: BRT vs BRT + Metro") + 
  geom_sf(aes(fill = diff_brt_brt_metro_Mean), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Mean commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_BRT_BRT_Metro_Mean.png", path = "Data/Results/Images/")
```
Median

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: BRT vs BRT + Metro") + 
  geom_sf(aes(fill = diff_brt_brt_metro_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_BRT_BRT_Metro_Median.png", path = "Data/Results/Images/")
```
Minimum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: BRT vs BRT + Metro") + 
  geom_sf(aes(fill = diff_brt_brt_metro_Min), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Minimum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_BRT_BRT_Metro_Min.png", path = "Data/Results/Images/")
```

Maximum

```{r}
ggplot(geo_sta_diff_ttm_hex9) +
  ggtitle("Time travel differece: BRT vs BRT + Metro") + 
  geom_sf(aes(fill = diff_brt_brt_metro_Max), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Maximum commuting time difference") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Ttm_diff_BRT_BRT_Metro_Max.png", path = "Data/Results/Images/")
```


### Extreme cases

#### Descriptive statistics

Descriptive statistics of ttm by mode

```{r}
sta_ttm_hex9 <- main_ttm_hex9 %>%
  group_by(from_id) %>%
  summarise(across(contains("tt"), list(
    Min = min,
    Max = max,
    Mean = mean,
    Median = median,
    SD = sd
  )))
```

Merging statistic results with hexagon matrix

```{r}
geo_sta_ttm_hex9 <- merge(
  hex_grid_9,
  sta_ttm_hex9,
  by.x = "h3_index",
  by.y = "from_id"
)
```

#### Plotting modes

Median walking time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = walk_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median walking time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median BRT time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = brt_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median BRT time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median Metro time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = metro_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median Metro time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

Median BRT + Metro time

```{r}
ggplot(geo_sta_ttm_hex9) +
  ggtitle("Time travel results") + 
  geom_sf(aes(fill = brt_metro_tt_Median), color = NA) +
  scale_fill_viridis_c(option = "inferno",direction = -1) +
  labs(fill = "Median BRT + Metro time") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))
```

### Walk

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == max(walk_tt))
```
Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == min(walk_tt))
```


### BRT

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_tt == max(brt_tt))
```

Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(walk_tt == min(walk_tt))
```



### Metro

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(metro_tt == max(metro_tt))
```

Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(metro_tt == min(metro_tt))
```

### BRT + Metro

Maximum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_metro_tt == max(brt_metro_tt))
```
Minimum travel time

```{r}
main_ttm_hex9 %>%
  filter(brt_metro_tt == min(brt_metro_tt))
```


### Sampled examples (pending)

Review of consistency of merge and values of ttm values across scenarios








## Parameters

### Duration thresholds

```{r}
# R5R parameters
r5r_1_global_cutoff <- 120 # minutes
r5r_1_max_walk_time <- 60 # minutes
r5r_1_max_trip_duration <- 120 # minutes
```


#### Walking 

##### R5R package


```{r}
r5r_access_walk_1 <- accessibility(
  r5r_walk,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = "WALK",
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```

##### Spatial distribution


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_walk_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_walk_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}
# plot_title <- paste("Walking accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)


ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = b_walk_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_Walk_C1.png", path = "Data/Results/Images/")
```


#### BRT

##### R5R package

```{r}
r5r_access_brt_1 <- accessibility(
  r5r_before,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid (not in use)

```{r}
# spatial_r5r_brt_1 <- merge(
#   hex_grid_9,
#   r5r_access_brt_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```


Merging with main results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_brt_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, b_brt_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}

# plot_title <- paste("BRT accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)



ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = b_brt_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_BRT_C1.png", path = "Data/Results/Images/")
```
#### Metro

##### R5R package

```{r}
r5r_access_metro_1 <- accessibility(
  r5r_metro,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "TRANSIT"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid

```{r}
# spatial_r5r_metro_1 <- merge(
#   hex_grid_9,
#   r5r_access_metro_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```


Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_metro_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, m_metro_x = accessibility)
```


Plotting

Regular Vidiris color scheme

```{r}
# plot_title <- paste("Metro accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)



ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = m_metro_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_Metro_C1.png", path = "Data/Results/Images/")
```
#### BRT + Metro

##### R5R package

```{r}
r5r_access_full_1 <- accessibility(
  r5r_after,
  origins = hex_points_main,
  destinations = hex_points_main,
  opportunities_colname = "LU_COD_21",
  decay_function = "step",
  cutoffs = r5r_1_global_cutoff,
  mode = c("WALK", "SUBWAY", "BUS"),
  departure_datetime = as.POSIXct(
    "06-06-2023 8:00:00",
    format = "%d-%m-%Y %H:%M:%S"
  ),
  max_walk_time = r5r_1_max_walk_time,
  max_trip_duration = r5r_1_max_trip_duration,
  verbose = FALSE,
  progress = FALSE
)
```


##### Spatial distribution

Merging accessibility results with hexagon grid (not in use)

```{r}
# spatial_r5r_full_1 <- merge(
#   hex_grid_9,
#   r5r_access_full_1,
#   by.x = "h3_index",
#   by.y = "id"
# )
```

Merging with main results matrix

```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  r5r_access_full_1[,c("id","accessibility")],
  by.x = "h3_index",
  by.y = "id"
)
```

Rename column

```{r}
main_results_hex9<- rename(main_results_hex9, a_brt_metro_x = accessibility)
```


Plotting


Regular Vidiris color scheme

```{r}

# plot_title <- paste("BRT and Metro accessibility: cutoffs = ",r5r_1_global_cutoff,",  max_walk_time = ",r5r_1_max_walk_time,", max_trip_duration = ", r5r_1_max_trip_duration)


ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = a_brt_metro_x), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessible\nHigh Street Retail Opportunities") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_BRT_Metro_C1.png", path = "Data/Results/Images/")
```


## Global measure comparison

### Summary

```{r}
summary(main_results_hex9)
```

## Global distribution variation

Median absolute variation

Before

```{r}
median(main_results_hex9[["b_brt_30"]])
```
After

```{r}
median(main_results_hex9[["a_brt_metro_30"]])
```

After - before

```{r}
median_variation_abs <- median(main_results_hex9[["a_brt_metro_30"]]) - median(main_results_hex9[["b_brt_30"]])
print(median_variation_abs)
```
Percentage

```{r}
median_variation_per <- median_variation_abs/median(main_results_hex9[["b_brt_30"]])
print(median_variation_per)
```

Upper quuartile absolute variation

Before

```{r}
unname(quantile(main_results_hex9[["b_brt_30"]],na.rm = T,probs = 0.75))

```
After

```{r}
unname(quantile(main_results_hex9[["a_brt_metro_30"]],na.rm = T,probs = 0.75))
```

After - before

```{r}
upper_q_variation_abs <- unname(quantile(main_results_hex9[["a_brt_metro_30"]],na.rm = T,probs = 0.75)) - unname(quantile(main_results_hex9[["b_brt_30"]],na.rm = T,probs = 0.75))
print(upper_q_variation_abs)
```
Percentage

```{r}
upper_q_variation_per <- upper_q_variation_abs/unname(quantile(main_results_hex9[["b_brt_30"]],na.rm = T,probs = 0.75))
print(upper_q_variation_per)
```


## Hexagon measure comparison


```{r}
main_results_hex9 <- main_results_hex9 %>%
  mutate(
    diff_b_brt_a_brt_metro = a_brt_metro_30 - b_brt_30)
  
```


### Plotting




Pivot longer

```{r}
main_results_hex9_longer_scatterplot <- pivot_longer(main_results_hex9,
                        cols = c(b_walk_30 , b_brt_30, m_metro_30,a_brt_metro_30),
                        names_to = "scenario",
                        values_to = "access_base")
```


Boxplot


```{r}

desired_scenario_order <- c("b_walk_30", "m_metro_30", "b_brt_30", "a_brt_metro_30")
desired_scenario_label <- c("Walking", "Metro", "BRT", "Brt and metro")

main_results_hex9_longer_scatterplot$scenario <- factor(
  main_results_hex9_longer_scatterplot$scenario,
  levels = desired_scenario_order
)

# Now create the ggplot with the modified order
ggplot(main_results_hex9_longer_scatterplot) +
  geom_boxplot(
    aes(
      x = scenario,
      y = access_base,
      fill = scenario
    ),
    show.legend = FALSE
  ) +
  scale_fill_viridis(discrete = TRUE) +  # Use scale_fill_viridis instead of scale_colour_viridis
  labs(
    x = "Scenario",
    y = "Opportunities"
  ) +
  scale_x_discrete(labels = desired_scenario_label)

ggsave("Boxplot_Access_Scenarios.png", path = "Data/Results/Images/")

```


Base

```{r}
# plot_title <- paste("BRT and Metro accessibility variation: cutoffs = ",r5r_global_cutoff,",  max_walk_time = ",r5r_max_walk_time,", max_trip_duration = ", r5r_max_trip_duration)



ggplot(main_results_hex9) +
  # ggtitle(plot_title) + 
  geom_sf(aes(fill = diff_b_brt_a_brt_metro), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Accessibility variation") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Access_diff_BRT_Metro_base.png", path = "Data/Results/Images/")
```
## Results assessment

### By income decile

Merge income data with results matrix


```{r}
main_results_hex9 <- merge(
  main_results_hex9,
  survey_add_intersect_hex9,
  by = "h3_index"
)
```

#### ZPU Map

Plot income decile

continuous scale

```{r}
ggplot(main_results_hex9) +
  #ggtitle("Mean income") + 
  geom_sf(aes(fill = income_decile), color = NA) +
  scale_fill_viridis_c() +
  labs(fill = "Mean household Income decile") +
  #theme_minimal()
  theme(plot.title = element_text(size = 8, face = "bold"))

ggsave("Demo_income_decile_cont.png", path = "Data/Results/Images/")
```



Discrete scale

```{r}
viridis_pal_d <- viridis_pal(option = "D", direction = 1)


ggplot(main_results_hex9) +
  geom_sf(aes(fill = factor(income_decile)), color = NA) +  
  scale_fill_manual(
    values = viridis_pal_d(10),  
    labels = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10")  # Decile labels
  ) +
  labs(fill = "Mean household Income decile") +
  #theme_minimal() +
  theme(
    plot.title = element_text(size = 8, face = "bold")
  )


ggsave("Demo_income_decile_discrete.png", path = "Data/Results/Images/")
```


```{r}

# Working

# # Create the plot
# p <- ggplot(main_results_hex9) +
#   geom_sf(aes(fill = factor(income_decile)), color = NA) +
#   scale_fill_viridis_d() +
#   labs(fill = "Income Decile") +
#   theme_minimal() +
#   theme(legend.position = "bottom") +
#   guides(fill = guide_legend(nrow = 1))
# 
# # Save the plot to an image file
# ggsave("Data/Results/Images/Demo_income_decile.png", plot = p, width = 7, height = 7)

```



#### Scarerplot

Before

```{r}
ggplot(main_results_hex9) +
  geom_boxplot(
    aes(
      x = as.factor(income_decile),
      y = b_brt_30 / 1000,
      color = as.factor(income_decile),
      #group = income_decile
    ),
    show.legend = FALSE
  ) +
  scale_colour_viridis(discrete = TRUE) +
  labs(
    x = "Income decile",
    y = "Opportunities\n(thousands)") +
  scale_x_discrete(labels = c("D1\npoorest", paste0("D", 2:9), "D10\nwealthiest")) # + theme_minimal()

ggsave("Boxplot_Access_B_by_income_decile.png", path = "Data/Results/Images/")
```
After

```{r}
ggplot(main_results_hex9) +
  geom_boxplot(
    aes(
      x = as.factor(income_decile),
      y = a_brt_metro_30 / 1000,
      color = as.factor(income_decile),
      #group = income_decile
    ),
    show.legend = FALSE
  ) +
  scale_colour_viridis(discrete = TRUE) +
  labs(
    x = "Income decile",
    y = "Opportunities\n(thousands)") +
  scale_x_discrete(labels = c("D1\npoorest", paste0("D", 2:9), "D10\nwealthiest")) # + theme_minimal()

ggsave("Boxplot_Access_A_by_income_decile.png", path = "Data/Results/Images/")
```
Before and after

Povit longer

```{r}
main_results_hex9_pivot_longer <- main_results_hex9[,c("h3_index","b_brt_30", "a_brt_metro_30", "income_decile")] %>%
    pivot_longer(cols = c("b_brt_30", "a_brt_metro_30"),
               names_to = "scenario",
               values_to = "accessible_jobs") %>%
  st_drop_geometry(.)
  
```

Review

```{r}
filter(main_results_hex9_pivot_longer, h3_index == "8966e082443ffff")
```

Levels

```{r}
main_results_hex9_pivot_longer$scenario <- factor(main_results_hex9_pivot_longer$scenario, levels = c("b_brt_30","a_brt_metro_30"))
```


Plot

```{r}
ggplot(main_results_hex9_pivot_longer) +
  geom_boxplot(
    aes(
      x = as.factor(income_decile),
      y = accessible_jobs / 1000,
      color = as.factor(income_decile),
      #weight = population,
      group = income_decile
    ),
    show.legend = FALSE
  ) +
  facet_wrap(
    ~ scenario,
    nrow = 1,
    labeller = as_labeller(c(b_brt_30 = "Current", a_brt_metro_30 = "Future"))
  ) +
  scale_colour_viridis(discrete = TRUE) +
  labs(x = "Income decile", y = "Opportunities (thousands)") +
  scale_x_discrete(
    labels = c("D1\npoorest", paste0("D", 2:9), "D10\nwealthiest")
  ) #+ theme_minimal()

ggsave("Boxplot_Access_All_by_income_decile.png", path = "Data/Results/Images/")
```


Difference

```{r}
ggplot(main_results_hex9) +
  geom_boxplot(
    aes(
      x = as.factor(income_decile),
      y = diff_b_brt_a_brt_metro / 1000,
      color = as.factor(income_decile),
      #group = income_decile
    ),
    show.legend = FALSE
  ) +
  scale_colour_viridis(discrete = TRUE) +
  labs(
    x = "Income decile",
    y = "Opportunities variation\n(thousands)") +
  scale_x_discrete(labels = c("D1\npoorest", paste0("D", 2:9), "D10\nwealthiest")) #+ theme_minimal()

ggsave("Boxplot_Access_diff_by_income_decile.png", path = "Data/Results/Images/")
```
### By income quartile

Have to do a pivot long with the quartile label

```{r}
ggplot(main_results_hex9_pivot_longer) +
  geom_boxplot(
    aes(
      x = as.factor(income_decile),
      y = accessible_jobs / 1000,
      color = as.factor(income_decile),
      #weight = population,
      group = income_decile
    ),
    show.legend = FALSE
  ) +
  facet_wrap(
    ~ scenario,
    nrow = 1,
    labeller = as_labeller(c(b_brt_30 = "Current", a_brt_metro_30 = "Future"))
  ) +
  scale_colour_viridis(discrete = TRUE) +
  labs(x = "Income decile", y = "Opportunities (thousands)") +
  scale_x_discrete(
    labels = c("D1\npoorest", paste0("D", 2:9), "D10\nwealthiest")
  ) #+ theme_minimal()

ggsave("Boxplot_Access_All_by_income_decile.png", path = "Data/Results/Images/")
```




### Write geopackage

```{r}
main_results_hex9 %>%
  st_write("Data/Results/After/Grid/Hex9_grid.gpkg",
           "Hex9_r5r_full",
           delete_layer=TRUE)
```






## Alternative scenario
